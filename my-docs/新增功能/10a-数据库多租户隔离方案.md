# 10a - 数据库多租户隔离方案

> 版本: 1.0 | 创建日期: 2026-02-12 | 状态: 规划中
>
> 上级文档: [10-多租户架构改造总体方案.md](./10-多租户架构改造总体方案.md)

---

## 1. 现状分析

### 1.1 数据库表分类

对现有 `src/db/schema/` 中全部表按多租户属性分类：

#### 用户级（需要 userId 隔离）

| 表名                    | userId 字段  | 当前状态 | 说明                 |
| ----------------------- | ------------ | -------- | -------------------- |
| `user_devices`          | ✅ userId FK | ✅ 已有  | 用户设备绑定         |
| `user_sessions`         | ✅ userId FK | ✅ 已有  | 用户登录会话         |
| `user_skills`           | ✅ userId FK | ✅ 已有  | 用户购买的技能       |
| `subscriptions`         | ✅ userId FK | ✅ 已有  | 用户订阅             |
| `payment_orders`        | ✅ userId FK | ✅ 已有  | 支付订单             |
| `audit_logs`            | ✅ userId FK | ✅ 已有  | 审计日志             |
| `export_logs`           | ✅ userId FK | ✅ 已有  | 导出日志             |
| `skill_store_items`     | ✅ authorId  | ✅ 已有  | 技能商店（作者隔离） |
| `skill_reviews`         | ✅ userId FK | ✅ 已有  | 技能评价             |
| `user_installed_skills` | ✅ userId FK | ✅ 已有  | 已安装技能           |

#### 系统级（全局共享，不需要 userId）

| 表名                    | 说明               |
| ----------------------- | ------------------ |
| `users`                 | 用户主表（被引用） |
| `plans`                 | 套餐定义           |
| `skills`                | 系统技能定义       |
| `skill_categories`      | 技能分类           |
| `coupon_codes`          | 优惠券             |
| `system_configs`        | 系统配置           |
| `config_change_history` | 配置变更历史       |
| `login_attempts`        | 登录尝试（按标识） |
| `verification_codes`    | 验证码             |

#### 管理员级（独立体系）

| 表名                   | 说明           |
| ---------------------- | -------------- |
| `admins`               | 管理员主表     |
| `admin_sessions`       | 管理员会话     |
| `admin_audit_logs`     | 管理员操作日志 |
| `admin_login_attempts` | 管理员登录尝试 |

### 1.2 核心问题

数据库 schema 层面 userId 外键已基本完备。**真正缺失的是代码层面的强制隔离**：

1. **Repository 层**：查询方法没有统一的 userId 注入机制
2. **Gateway RPC 层**：大部分方法没有从认证上下文提取 userId
3. **Agent 运行时**：Session、Tool 调用没有 userId 上下文

---

## 2. 改造方案

### 2.1 Repository 层改造

#### 策略：混合模式

对不同类型的 Repository 采用不同策略：

| Repository 类型      | 策略                 | 示例                          |
| -------------------- | -------------------- | ----------------------------- |
| 用户数据 Repository  | 构造函数注入 userId  | ConversationRepo, MemoryRepo  |
| 现有 userId 查询方法 | 保持现有方法签名不变 | SubscriptionRepo.findByUser() |
| 系统级 Repository    | 不需要 userId        | PlanRepo, SkillCategoryRepo   |
| 管理员 Repository    | adminId 隔离（已有） | AdminRepo                     |

#### 2.1.1 新增 TenantScope 基类

```typescript
// src/db/repositories/tenant-scope.ts

/**
 * 租户作用域基类
 *
 * 为用户级 Repository 提供自动 userId 过滤能力
 */
export class TenantScopedRepository {
  constructor(
    protected readonly db: Database,
    protected readonly userId: string,
  ) {
    if (!userId) {
      throw new Error("[TenantScopedRepository] userId is required");
    }
  }

  /** 获取当前租户 ID */
  get tenantId(): string {
    return this.userId;
  }
}
```

#### 2.1.2 新增 Repository 使用示例

```typescript
// src/db/repositories/conversations.ts

export class ConversationRepository extends TenantScopedRepository {
  /**
   * 查询用户的所有对话 — 自动带 userId 过滤
   */
  async findAll(options?: { limit?: number; offset?: number }) {
    return this.db
      .select()
      .from(conversations)
      .where(eq(conversations.userId, this.userId)) // 强制隔离
      .limit(options?.limit ?? 20)
      .offset(options?.offset ?? 0)
      .orderBy(desc(conversations.updatedAt));
  }

  /**
   * 按 ID 查找 — 自动附加 userId 校验
   */
  async findById(id: string) {
    const [row] = await this.db
      .select()
      .from(conversations)
      .where(
        and(
          eq(conversations.id, id),
          eq(conversations.userId, this.userId), // 防止越权
        ),
      );
    return row ?? null;
  }
}
```

#### 2.1.3 现有 Repository 改造

现有 Repository（如 `SubscriptionRepository`）已有部分方法接受 userId 参数，这些**保持不变**，仅补充缺失的 userId 过滤：

```typescript
// 现有代码 — 保持不变
class SubscriptionRepository {
  async findByUser(userId: string) { ... }  // ✅ 已有 userId 参数
  async findActive(userId: string) { ... }  // ✅ 已有 userId 参数
}

// 需要检查并补充的
class SubscriptionRepository {
  async findById(id: string) { ... }  // ⚠️ 缺少 userId 校验
  // 改为：
  async findById(id: string, userId?: string) {
    const conditions = [eq(subscriptions.id, id)];
    if (userId) {
      conditions.push(eq(subscriptions.userId, userId));
    }
    const [row] = await this.db
      .select()
      .from(subscriptions)
      .where(and(...conditions));
    return row ?? null;
  }
}
```

### 2.2 Gateway RPC 层改造

#### 2.2.1 userId 上下文提取

Gateway 现有两套认证体系：

| 认证类型   | Token 来源                          | 提取 userId 方式                          |
| ---------- | ----------------------------------- | ----------------------------------------- |
| 用户认证   | `params.authorization` Bearer Token | JWT decode → payload.userId               |
| 管理员认证 | `params.authorization` Bearer Token | JWT decode → payload.adminId              |
| 设备认证   | 连接级 token                        | Gateway client → paired deviceId → userId |

#### 2.2.2 新增 RPC 上下文工具函数

```typescript
// src/gateway/auth-context.ts

interface UserContext {
  userId: string;
  deviceId?: string;
  role?: string;
}

/**
 * 从 RPC 参数中提取用户上下文
 *
 * 优先从 JWT token 提取，回退到设备绑定关系
 */
function extractUserContext(params: Record<string, unknown>): UserContext {
  // 1. 尝试从 Bearer Token 提取
  const authorization = params.authorization as string | undefined;
  if (authorization) {
    const token = authorization.replace("Bearer ", "");
    const payload = verifyJwt(token);
    return {
      userId: payload.userId,
      role: payload.role,
    };
  }

  // 2. 从设备连接中提取
  const clientId = params.__clientId as string | undefined;
  if (clientId) {
    const device = getConnectedDevice(clientId);
    return {
      userId: device.userId,
      deviceId: device.deviceId,
    };
  }

  throw new AuthError("No valid authentication context");
}
```

#### 2.2.3 RPC 方法改造模式

```typescript
// 改造前
'assistant.fileList': async (params) => {
  const files = await listFiles(params.path);  // 无 userId 隔离
  return { files };
},

// 改造后
'assistant.fileList': async (params) => {
  const ctx = extractUserContext(params);
  const files = await listFiles(ctx.userId, params.path);  // userId 隔离
  return { files };
},
```

### 2.3 改造清单

#### 需要检查的 Repository 文件

| 文件                                   | 需改造方法                   | 优先级 |
| -------------------------------------- | ---------------------------- | ------ |
| `src/db/repositories/users.ts`         | findById 增加 isActive 校验  | P1     |
| `src/db/repositories/subscriptions.ts` | findById 增加可选 userId     | P1     |
| `src/db/repositories/audit.ts`         | findAll 增加可选 userId 过滤 | P2     |

#### 需要检查的 RPC 方法文件

| 文件                                                | 说明                          | 优先级 |
| --------------------------------------------------- | ----------------------------- | ------ |
| `src/gateway/server-methods/assistant-auth.ts`      | 用户认证相关                  | P0     |
| `src/gateway/server-methods/assistant-skills.ts`    | 用户技能操作                  | P0     |
| `src/gateway/server-methods/assistant-device.ts`    | 用户设备操作                  | P0     |
| `src/gateway/server-methods/assistant.ts`           | 用户助手操作                  | P0     |
| `src/gateway/server-methods/chat.ts`                | 对话（需绑定 userId）         | P0     |
| `src/gateway/server-methods/admin-users.ts`         | 管理员操作（已有 admin 鉴权） | P1     |
| `src/gateway/server-methods/admin-subscriptions.ts` | 管理员操作                    | P1     |

---

## 3. 实施步骤

### Step 1: 创建 TenantScope 基类

- 新建 `src/db/repositories/tenant-scope.ts`
- 导出 `TenantScopedRepository` 基类
- 单元测试验证 userId 必填检查

### Step 2: 创建 auth-context 工具

- 新建 `src/gateway/auth-context.ts`
- 实现 `extractUserContext()` 函数
- 单元测试验证 JWT 提取和设备回退逻辑

### Step 3: 逐模块改造 RPC 方法

按优先级逐个模块改造，每改完一个模块就测试：

1. `assistant-auth.ts` — 用户认证（基础）
2. `chat.ts` — 对话（核心）
3. `assistant-device.ts` — 设备操作
4. `assistant-skills.ts` — 技能操作
5. 其余 assistant-\*.ts 方法

### Step 4: 补充集成测试

- 测试用例：用户 A 的数据对用户 B 不可见
- 测试用例：无认证上下文时拒绝访问
- 测试用例：系统级数据所有用户可见

---

## 4. 验收标准

| #   | 标准                                      | 验证方式 |
| --- | ----------------------------------------- | -------- |
| 1   | TenantScopedRepository 构造时 userId 必填 | 单元测试 |
| 2   | extractUserContext 正确提取 JWT userId    | 单元测试 |
| 3   | 用户 A 查不到用户 B 的对话/订阅/设备      | 集成测试 |
| 4   | 管理员可以跨用户查询（管理后台需要）      | 集成测试 |
| 5   | 系统级数据（plans, categories）全局可见   | 集成测试 |
| 6   | 现有功能不受影响                          | 回归测试 |

---

_— 文档结束 —_
