# AI 个人助理平台 - 记忆系统需求文档

> 版本: 1.0 | 创建日期: 2026-02-07 | 状态: 设计中
>
> 本文档定义可插拔记忆系统的功能需求、使用场景和验收标准

---

## 1. 文档概述

### 1.1 目的

本文档详细描述 AI 个人助理平台记忆系统的功能需求和使用场景。该记忆系统设计为**可插拔模块**，不仅服务于 OpenClaw 平台和 Windows 助理客户端，还可独立部署用于其他 AI 应用系统。

### 1.2 范围

| 范围项 | 包含 | 不包含 |
|--------|------|--------|
| 记忆类型 | 工作、情节、画像、知识四层记忆 | 传感器/物理记忆 |
| 存储后端 | MinIO、PostgreSQL、Neo4j、Milvus | 其他未列出的存储 |
| 集成系统 | OpenClaw、Windows 客户端、独立部署 | 移动端原生集成 |
| 多媒体 | 文档、图片、音频、视频 | 3D 模型、VR/AR 内容 |

### 1.3 术语定义

| 术语 | 定义 |
|------|------|
| **工作记忆 (Working Memory)** | 当前会话的临时上下文，会话结束后清理 |
| **情节记忆 (Episodic Memory)** | 长期对话历史，包含摘要、关键事件、时间线 |
| **画像记忆 (Profile Memory)** | 用户事实、偏好、行为模式的持久化存储 |
| **知识记忆 (Knowledge Memory)** | 结构化知识库，包含向量索引和知识图谱 |
| **记忆提供者 (Memory Provider)** | 实现记忆接口的具体后端实现 |
| **记忆上下文 (Memory Context)** | 聚合多层记忆的用户完整上下文 |

### 1.4 现有系统分析

基于对 OpenClaw 现有代码的分析：

| 组件 | 现状 | 问题 |
|------|------|------|
| **会话存储** | JSON5 文件 + JSONL 记录 | 无结构化查询、无用户隔离 |
| **记忆索引** | SQLite + sqlite-vec | 单机限制、无分布式支持 |
| **嵌入模型** | OpenAI/Gemini/本地 | 无统一管理接口 |
| **搜索方式** | 混合搜索 (0.7 向量 + 0.3 BM25) | 无知识图谱支持 |
| **媒体存储** | 文件系统 + 2 分钟 TTL | 不持久、无对象存储 |

---

## 2. 用户角色

### 2.1 角色定义

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户角色层次                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐         │
│   │  终端用户    │    │  管理员      │    │  开发者      │         │
│   │  End User   │    │  Admin      │    │  Developer  │         │
│   └──────┬──────┘    └──────┬──────┘    └──────┬──────┘         │
│          │                  │                  │                 │
│          ▼                  ▼                  ▼                 │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐         │
│   │ • 对话交互   │    │ • 系统配置   │    │ • 接口开发   │         │
│   │ • 知识上传   │    │ • 用户管理   │    │ • 提供者实现 │         │
│   │ • 记忆查看   │    │ • 记忆审计   │    │ • 系统集成   │         │
│   │ • 偏好设置   │    │ • 备份恢复   │    │ • 扩展开发   │         │
│   └─────────────┘    └─────────────┘    └─────────────┘         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 角色权限矩阵

| 功能 | 终端用户 | 管理员 | 开发者 |
|------|:------:|:------:|:------:|
| 创建对话会话 | ✅ | ✅ | ✅ |
| 查看自己的记忆 | ✅ | ✅ | ✅ |
| 上传知识文档 | ✅ | ✅ | ✅ |
| 删除自己的记忆 | ✅ | ✅ | ✅ |
| 查看所有用户记忆 | ❌ | ✅ | ❌ |
| 配置记忆策略 | ❌ | ✅ | ✅ |
| 实现新的提供者 | ❌ | ❌ | ✅ |
| 系统集成配置 | ❌ | ✅ | ✅ |
| 数据导入导出 | ✅ (自己) | ✅ (全部) | ✅ (全部) |

---

## 3. 功能需求

### 3.1 工作记忆 (Working Memory)

#### 3.1.1 功能描述

工作记忆管理当前对话会话的临时上下文，类似人类的"短期记忆"，用于维护对话连贯性。

#### 3.1.2 用户故事

| ID | 角色 | 故事 | 验收标准 |
|----|------|------|----------|
| WM-01 | 用户 | 作为用户，我希望 AI 能记住当前对话中提到的内容 | 同一会话内引用之前的内容能被正确理解 |
| WM-02 | 用户 | 作为用户，我希望能在对话中使用临时变量 | 设置变量后可在后续对话中引用 |
| WM-03 | 用户 | 作为用户，我希望长时间不活动后会话自动清理 | 超过 TTL 后会话数据被清理 |
| WM-04 | 系统 | 作为系统，我需要追踪正在执行的工具状态 | 工具执行状态可查询和恢复 |
| WM-05 | 系统 | 作为系统，我需要管理待确认的敏感操作 | 敏感操作排队等待用户确认 |

#### 3.1.3 功能点

```
工作记忆功能点
│
├── 会话管理
│   ├── WM-F01: 创建会话 - 为用户创建新的对话会话
│   ├── WM-F02: 获取会话 - 获取指定会话的完整状态
│   ├── WM-F03: 更新会话 - 更新会话元数据
│   ├── WM-F04: 删除会话 - 清理会话及其所有数据
│   └── WM-F05: 会话超时 - 自动清理超时会话
│
├── 消息管理
│   ├── WM-F06: 添加消息 - 追加新消息到会话
│   ├── WM-F07: 获取消息 - 获取会话消息列表
│   ├── WM-F08: 上下文窗口 - 按 Token 限制获取上下文
│   └── WM-F09: 消息压缩 - 超出窗口时自动摘要压缩
│
├── 状态管理
│   ├── WM-F10: 设置变量 - 存储临时键值对
│   ├── WM-F11: 获取变量 - 读取临时变量
│   ├── WM-F12: 清理变量 - 清空所有临时变量
│   ├── WM-F13: 工具状态 - 追踪工具执行状态
│   └── WM-F14: 待确认队列 - 管理待确认操作
│
└── 跨设备同步
    ├── WM-F15: 状态同步 - 同步会话状态到远程
    └── WM-F16: 恢复会话 - 从远程恢复会话状态
```

#### 3.1.4 非功能需求

| 属性 | 要求 |
|------|------|
| **延迟** | 消息追加 < 50ms |
| **并发** | 支持单用户多设备并发访问 |
| **可靠性** | 会话状态不丢失（本地缓存 + 远程同步） |
| **TTL** | 默认 30 分钟，可配置 |

---

### 3.2 情节记忆 (Episodic Memory)

#### 3.2.1 功能描述

情节记忆存储用户的长期对话历史，自动生成摘要、提取关键事件，构建用户交互时间线。

#### 3.2.2 用户故事

| ID | 角色 | 故事 | 验收标准 |
|----|------|------|----------|
| EM-01 | 用户 | 作为用户，我希望 AI 能记住我们之前的对话 | 引用历史对话内容能被正确理解 |
| EM-02 | 用户 | 作为用户，我希望能搜索历史对话 | 按关键词/时间/主题搜索历史 |
| EM-03 | 用户 | 作为用户，我希望看到我和 AI 的交互时间线 | 可视化展示重要事件时间线 |
| EM-04 | 用户 | 作为用户，我希望 AI 记住重要的约定和决定 | 重要决定被标记并可查询 |
| EM-05 | 系统 | 作为系统，我需要自动生成对话摘要 | 会话结束时自动生成摘要 |
| EM-06 | 系统 | 作为系统，我需要追踪用户情绪变化 | 记录对话中的情绪状态 |

#### 3.2.3 功能点

```
情节记忆功能点
│
├── 对话历史
│   ├── EM-F01: 存储对话 - 保存完整对话到历史
│   ├── EM-F02: 生成摘要 - AI 自动生成对话摘要
│   ├── EM-F03: 提取主题 - 识别对话主要话题
│   ├── EM-F04: 记录决定 - 提取对话中的决定
│   └── EM-F05: 查询历史 - 按条件查询对话历史
│
├── 关键事件
│   ├── EM-F06: 事件检测 - 自动检测关键事件
│   ├── EM-F07: 事件分类 - 任务完成/偏好变更/里程碑等
│   ├── EM-F08: 事件评分 - 计算事件重要性分数
│   └── EM-F09: 事件查询 - 按类型/时间查询事件
│
├── 时间线
│   ├── EM-F10: 构建时间线 - 生成用户交互时间线
│   ├── EM-F11: 时间范围查询 - 按日期范围获取记录
│   └── EM-F12: 时间线可视化 - 支持 UI 渲染的数据格式
│
├── 情绪追踪
│   ├── EM-F13: 情绪检测 - 分析对话情绪状态
│   ├── EM-F14: 满意度计算 - 计算用户满意度
│   └── EM-F15: 情绪趋势 - 追踪情绪变化趋势
│
└── 搜索功能
    ├── EM-F16: 语义搜索 - 按语义相似度搜索
    ├── EM-F17: 关键词搜索 - 按关键词精确搜索
    └── EM-F18: 混合搜索 - 结合语义和关键词
```

#### 3.2.4 使用场景

**场景 1: 回顾历史决定**

```
用户: "上周我们讨论的那个项目方案，最后决定用哪个了？"
系统行为:
1. 在情节记忆中搜索最近一周的对话
2. 查找标记为 "decision" 类型的事件
3. 过滤与 "项目方案" 相关的记录
4. 返回决定内容和上下文

响应: "根据上周三的对话，您决定采用方案 B，主要因为..."
```

**场景 2: 时间线查询**

```
用户: "展示我这个月和你的所有重要互动"
系统行为:
1. 获取本月的时间线数据
2. 过滤重要性分数 > 0.7 的事件
3. 按时间排序
4. 格式化为时间线视图

响应: [渲染可视化时间线，包含任务完成、重要决定等]
```

---

### 3.3 画像记忆 (Profile Memory)

#### 3.3.1 功能描述

画像记忆存储用户的事实信息、偏好设置和行为模式，用于个性化 AI 响应。

#### 3.3.2 用户故事

| ID | 角色 | 故事 | 验收标准 |
|----|------|------|----------|
| PM-01 | 用户 | 作为用户，我希望 AI 记住我的个人信息 | 称呼、职业等信息被记住 |
| PM-02 | 用户 | 作为用户，我希望 AI 了解我的偏好 | 响应风格符合我的偏好 |
| PM-03 | 用户 | 作为用户，我希望能管理 AI 对我的了解 | 可查看、编辑、删除事实 |
| PM-04 | 用户 | 作为用户，我希望 AI 能推断我的习惯 | 根据行为模式提供建议 |
| PM-05 | 系统 | 作为系统，我需要从对话中提取用户信息 | 自动提取事实到画像 |
| PM-06 | 系统 | 作为系统，我需要处理信息冲突 | 新旧信息冲突时合理处理 |

#### 3.3.3 功能点

```
画像记忆功能点
│
├── 事实管理
│   ├── PM-F01: 添加事实 - 记录用户事实信息
│   ├── PM-F02: 更新事实 - 更新已有事实
│   ├── PM-F03: 删除事实 - 删除指定事实
│   ├── PM-F04: 查询事实 - 按类别/关键词查询
│   ├── PM-F05: 事实置信度 - 维护事实可信度
│   └── PM-F06: 事实来源 - 追踪事实来源 (显式/推断)
│
├── 偏好设置
│   ├── PM-F07: 获取偏好 - 获取用户偏好配置
│   ├── PM-F08: 更新偏好 - 更新偏好设置
│   ├── PM-F09: 偏好建议 - 根据行为建议偏好
│   └── PM-F10: 偏好导出 - 导出偏好配置
│
├── 行为模式
│   ├── PM-F11: 模式检测 - 检测用户行为模式
│   ├── PM-F12: 模式记录 - 记录检测到的模式
│   ├── PM-F13: 模式应用 - 根据模式调整行为
│   └── PM-F14: 模式反馈 - 用户确认/否定模式
│
├── 自动提取
│   ├── PM-F15: 对话提取 - 从对话中提取事实
│   ├── PM-F16: 冲突处理 - 处理新旧信息冲突
│   ├── PM-F17: 提取确认 - 重要事实请求确认
│   └── PM-F18: 提取历史 - 查看提取历史
│
└── 隐私控制
    ├── PM-F19: 敏感标记 - 标记敏感信息
    ├── PM-F20: 访问控制 - 控制信息使用范围
    └── PM-F21: 遗忘请求 - 处理用户遗忘请求
```

#### 3.3.4 事实类别定义

| 类别 | 示例 | 敏感级别 |
|------|------|----------|
| **personal** | 姓名、生日、家乡 | 中 |
| **work** | 公司、职位、行业 | 低 |
| **hobby** | 兴趣爱好、运动 | 低 |
| **skill** | 编程语言、专业技能 | 低 |
| **relationship** | 家人、朋友、同事 | 高 |
| **health** | 健康状况、过敏 | 高 |
| **finance** | 收入、资产 | 高 |
| **other** | 其他事实 | 中 |

#### 3.3.5 使用场景

**场景 1: 个性化问候**

```
用户: "早上好"
系统行为:
1. 获取用户画像
2. 检查用户名称 -> "张三"
3. 检查时间偏好 -> 喜欢简洁问候
4. 检查行为模式 -> 工作日早上通常处理邮件

响应: "早上好，张三！需要我帮你检查一下今天的邮件吗？"
```

**场景 2: 自动提取事实**

```
用户: "我下周要去杭州出差，帮我查一下那边的天气"
系统行为:
1. 处理用户请求（查天气）
2. 检测到新事实: "下周去杭州出差"
3. 创建事实记录:
   - category: "work"
   - key: "upcoming_trip"
   - value: "杭州出差"
   - validUntil: 下周末
   - source: "explicit"
4. 后续对话可引用此计划
```

---

### 3.4 知识记忆 (Knowledge Memory)

#### 3.4.1 功能描述

知识记忆管理用户的结构化知识库，支持文档上传、向量索引、知识图谱构建和智能检索。

#### 3.4.2 用户故事

| ID | 角色 | 故事 | 验收标准 |
|----|------|------|----------|
| KM-01 | 用户 | 作为用户，我希望上传文档让 AI 学习 | 上传的文档内容可被 AI 引用 |
| KM-02 | 用户 | 作为用户，我希望 AI 能基于我的知识库回答问题 | 回答引用知识库内容并标注来源 |
| KM-03 | 用户 | 作为用户，我希望能管理我的知识库 | 可查看、删除、重新索引文档 |
| KM-04 | 用户 | 作为用户，我希望将对话转化为知识 | 重要对话可保存为知识 |
| KM-05 | 系统 | 作为系统，我需要构建知识图谱 | 从文档中提取实体和关系 |
| KM-06 | 系统 | 作为系统，我需要支持复杂知识查询 | 支持多跳推理查询 |

#### 3.4.3 功能点

```
知识记忆功能点
│
├── 文档管理
│   ├── KM-F01: 上传文档 - 支持多种格式文档上传
│   ├── KM-F02: 解析文档 - 提取文档文本内容
│   ├── KM-F03: 文档分块 - 按语义切分文档
│   ├── KM-F04: 列表文档 - 查看用户文档列表
│   ├── KM-F05: 删除文档 - 删除文档及其索引
│   └── KM-F06: 重新索引 - 重建文档索引
│
├── 向量索引
│   ├── KM-F07: 生成嵌入 - 为文档块生成向量
│   ├── KM-F08: 向量存储 - 存储向量到向量数据库
│   ├── KM-F09: 向量搜索 - 按语义相似度搜索
│   ├── KM-F10: 混合搜索 - 向量 + BM25 混合检索
│   └── KM-F11: 重排序 - 结果精排
│
├── 知识图谱
│   ├── KM-F12: 实体提取 - 从文档提取实体
│   ├── KM-F13: 关系提取 - 识别实体间关系
│   ├── KM-F14: 图谱存储 - 存储到图数据库
│   ├── KM-F15: 图谱查询 - 支持 Cypher 查询
│   ├── KM-F16: 上下文获取 - 获取实体关联上下文
│   └── KM-F17: 社区检测 - GraphRAG 社区摘要
│
├── 知识问答
│   ├── KM-F18: 知识检索 - 检索相关知识片段
│   ├── KM-F19: 上下文构建 - 组装问答上下文
│   ├── KM-F20: 来源引用 - 回答标注知识来源
│   └── KM-F21: 置信度评估 - 评估回答可信度
│
└── 对话转知识
    ├── KM-F22: 对话导入 - 将对话作为知识源
    ├── KM-F23: 知识提取 - 从对话提取结构化知识
    └── KM-F24: 关联建立 - 建立新旧知识关联
```

#### 3.4.4 支持的文档格式

| 格式 | 扩展名 | 处理方式 |
|------|--------|----------|
| **PDF** | .pdf | pdf-parse / pdfjs |
| **Word** | .docx | mammoth |
| **Excel** | .xlsx | xlsx |
| **PowerPoint** | .pptx | pptx-parser |
| **Markdown** | .md | marked |
| **纯文本** | .txt | 直接读取 |
| **HTML** | .html | cheerio |
| **JSON** | .json | 直接解析 |

#### 3.4.5 使用场景

**场景 1: 文档知识问答**

```
用户: [上传公司产品手册.pdf]
用户: "我们产品的核心优势是什么？"

系统行为:
1. 解析上传的 PDF
2. 分块并生成向量索引
3. 提取实体和关系到知识图谱
4. 收到问题后，执行混合搜索
5. 检索到相关片段
6. 生成带来源引用的回答

响应: "根据产品手册第 3 章，贵公司产品的核心优势包括：
1. 技术优势: ... [来源: 产品手册 P15]
2. 成本优势: ... [来源: 产品手册 P18]
3. 服务优势: ... [来源: 产品手册 P22]"
```

**场景 2: 对话转知识**

```
用户: "把我们刚才关于项目架构的讨论保存下来"

系统行为:
1. 获取当前会话对话记录
2. 使用 LLM 提取结构化知识:
   - 实体: 项目X、微服务架构、Redis、PostgreSQL
   - 关系: 项目X -使用-> 微服务架构
           项目X -缓存层-> Redis
           项目X -数据库-> PostgreSQL
3. 存储到知识图谱
4. 生成对话摘要存储到向量库

响应: "已保存！我从对话中提取了 4 个实体和 3 个关系，
并生成了对话摘要。后续可以直接询问项目架构相关问题。"
```

**场景 3: 多跳知识推理**

```
用户: "张三的领导是谁？"

知识图谱状态:
- 张三 -就职于-> 产品部
- 产品部 -负责人-> 李四

系统行为:
1. 识别问题需要多跳推理
2. 查询: 张三 -> 所属部门 -> 部门负责人
3. 路径: 张三 -> 产品部 -> 李四
4. 生成回答

响应: "根据组织架构，张三在产品部工作，产品部的负责人是李四，
所以张三的领导是李四。"
```

---

### 3.5 多媒体存储

#### 3.5.1 功能描述

多媒体存储使用 MinIO 对象存储管理用户上传的图片、音频、视频等文件。

#### 3.5.2 用户故事

| ID | 角色 | 故事 | 验收标准 |
|----|------|------|----------|
| MS-01 | 用户 | 作为用户，我希望能上传图片让 AI 分析 | 图片被存储并可被 AI 理解 |
| MS-02 | 用户 | 作为用户，我希望能分享语音消息 | 语音被转录并可被 AI 理解 |
| MS-03 | 用户 | 作为用户，我希望能获取文件的预览 | 文档/视频有缩略图预览 |
| MS-04 | 系统 | 作为系统，我需要持久化存储媒体文件 | 文件不会因 TTL 丢失 |
| MS-05 | 系统 | 作为系统，我需要生成媒体变体 | 图片有多种尺寸，视频有预览 |

#### 3.5.3 功能点

```
多媒体存储功能点
│
├── 文件上传
│   ├── MS-F01: 直接上传 - 上传文件到对象存储
│   ├── MS-F02: 分片上传 - 大文件分片上传
│   ├── MS-F03: 格式检测 - 检测文件 MIME 类型
│   └── MS-F04: 大小限制 - 按类型限制文件大小
│
├── 文件处理
│   ├── MS-F05: 图片处理 - 生成缩略图和中等尺寸
│   ├── MS-F06: 视频处理 - 提取缩略图和元数据
│   ├── MS-F07: 音频处理 - 提取时长和波形
│   └── MS-F08: 文档预览 - 生成 PDF 首页预览
│
├── 文件访问
│   ├── MS-F09: 直接下载 - 下载原始文件
│   ├── MS-F10: 流式下载 - 流式传输大文件
│   ├── MS-F11: 预签名 URL - 生成临时访问链接
│   └── MS-F12: CDN 加速 - 通过 CDN 加速访问
│
├── 文件管理
│   ├── MS-F13: 列表文件 - 查看用户文件列表
│   ├── MS-F14: 删除文件 - 删除文件及其变体
│   ├── MS-F15: 元数据查询 - 查询文件元数据
│   └── MS-F16: 存储统计 - 统计用户存储用量
│
└── AI 集成
    ├── MS-F17: 图片理解 - 图片内容理解接口
    ├── MS-F18: 语音转录 - 语音转文字接口
    └── MS-F19: 视频理解 - 视频内容理解接口
```

#### 3.5.4 存储桶设计

| 存储桶 | 用途 | 生命周期 | 访问策略 |
|--------|------|----------|----------|
| **documents** | 知识文档 | 永久 | 私有 |
| **media** | 多媒体文件 | 永久 | 预签名访问 |
| **temp** | 临时文件 | 24 小时 | 私有 |
| **exports** | 导出文件 | 7 天 | 预签名访问 |

---

### 3.6 可插拔架构

#### 3.6.1 设计原则

```
┌─────────────────────────────────────────────────────────────────┐
│                     可插拔架构设计原则                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 接口优先 (Interface First)                                   │
│     - 所有记忆类型定义统一接口                                    │
│     - 实现与接口分离                                             │
│     - 支持多种后端实现                                            │
│                                                                  │
│  2. 依赖注入 (Dependency Injection)                              │
│     - 通过工厂创建提供者实例                                       │
│     - 运行时动态切换实现                                          │
│     - 配置驱动的提供者选择                                        │
│                                                                  │
│  3. 独立部署 (Standalone Deployment)                             │
│     - 记忆系统可独立于主应用部署                                   │
│     - 通过 RPC/HTTP 提供服务                                     │
│     - 支持容器化部署                                              │
│                                                                  │
│  4. 零侵入集成 (Non-Invasive Integration)                        │
│     - 集成时不修改现有代码结构                                     │
│     - 通过配置启用/禁用功能                                        │
│     - 支持渐进式迁移                                              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

#### 3.6.2 提供者矩阵

| 记忆类型 | 推荐实现 | 备选实现 | 轻量实现 |
|----------|----------|----------|----------|
| **工作记忆** | Mem0 | Redis | 内存 Map |
| **情节记忆** | Mem0 | Zep | PostgreSQL |
| **画像记忆** | Mem0 | PostgreSQL | SQLite |
| **知识记忆** | Graphiti + Milvus | GraphRAG | SQLite + sqlite-vec |
| **对象存储** | MinIO | AWS S3 | 本地文件系统 |

#### 3.6.3 集成场景

**场景 A: OpenClaw 集成**

```yaml
# openclaw 配置
memory:
  provider: pluggable
  endpoint: http://localhost:8081  # 独立记忆服务
  # 或嵌入式
  embedded: true
  config:
    working: { provider: mem0 }
    episodic: { provider: mem0 }
    profile: { provider: postgres }
    knowledge: { provider: graphiti }
    storage: { provider: minio }
```

**场景 B: Windows 客户端集成**

```yaml
# Windows 客户端配置
memory:
  # 使用远程服务
  endpoint: https://memory.example.com
  # 本地缓存
  localCache:
    enabled: true
    path: ./cache/memory
    ttl: 3600
```

**场景 C: 独立服务部署**

```yaml
# 独立记忆服务配置
server:
  port: 8081
  auth:
    type: jwt
    secret: ${JWT_SECRET}

memory:
  working: { provider: redis, ... }
  episodic: { provider: mem0, ... }
  profile: { provider: postgres, ... }
  knowledge: { provider: graphiti, ... }
  storage: { provider: minio, ... }
```

---

## 4. 接口需求

### 4.1 工作记忆接口

```typescript
interface IWorkingMemoryProvider {
  // 生命周期
  initialize(): Promise<void>
  shutdown(): Promise<void>
  healthCheck(): Promise<HealthStatus>

  // 会话管理
  createSession(userId: string, options?: SessionOptions): Promise<string>
  getSession(sessionId: string): Promise<WorkingMemory | null>
  updateSession(sessionId: string, updates: Partial<WorkingMemory>): Promise<void>
  deleteSession(sessionId: string): Promise<void>
  listSessions(userId: string): Promise<SessionInfo[]>

  // 消息管理
  addMessage(sessionId: string, message: Message): Promise<void>
  getMessages(sessionId: string, limit?: number): Promise<Message[]>
  getContextWindow(sessionId: string, maxTokens: number): Promise<Message[]>

  // 状态管理
  setVariable(sessionId: string, key: string, value: unknown): Promise<void>
  getVariable(sessionId: string, key: string): Promise<unknown>
  clearVariables(sessionId: string): Promise<void>
  getToolStates(sessionId: string): Promise<ToolState[]>
  getPendingConfirms(sessionId: string): Promise<PendingConfirm[]>
}
```

### 4.2 情节记忆接口

```typescript
interface IEpisodicMemoryProvider {
  // 生命周期
  initialize(): Promise<void>
  shutdown(): Promise<void>
  healthCheck(): Promise<HealthStatus>

  // 对话历史
  addConversation(userId: string, sessionId: string, messages: Message[]): Promise<void>
  summarizeConversation(userId: string, sessionId: string): Promise<ConversationSummary>
  getConversationHistory(userId: string, options?: QueryOptions): Promise<ConversationSummary[]>
  deleteConversation(userId: string, sessionId: string): Promise<void>

  // 关键事件
  addKeyEvent(userId: string, event: Omit<KeyEvent, 'id'>): Promise<string>
  getKeyEvents(userId: string, options?: EventQueryOptions): Promise<KeyEvent[]>
  updateKeyEvent(userId: string, eventId: string, updates: Partial<KeyEvent>): Promise<void>
  deleteKeyEvent(userId: string, eventId: string): Promise<void>

  // 搜索
  searchEpisodes(userId: string, query: string, options?: SearchOptions): Promise<EpisodeSearchResult[]>
  getTimeline(userId: string, startDate: Date, endDate: Date): Promise<TimelineEntry[]>

  // 情绪追踪
  recordEmotion(userId: string, sessionId: string, emotion: EmotionalRecord): Promise<void>
  getEmotionTrend(userId: string, startDate: Date, endDate: Date): Promise<EmotionTrend>
}
```

### 4.3 画像记忆接口

```typescript
interface IProfileMemoryProvider {
  // 生命周期
  initialize(): Promise<void>
  shutdown(): Promise<void>
  healthCheck(): Promise<HealthStatus>

  // 事实管理
  addFact(userId: string, fact: Omit<UserFact, 'id' | 'createdAt'>): Promise<string>
  updateFact(userId: string, factId: string, updates: Partial<UserFact>): Promise<void>
  deleteFact(userId: string, factId: string): Promise<void>
  getFacts(userId: string, category?: string): Promise<UserFact[]>
  searchFacts(userId: string, query: string): Promise<UserFact[]>

  // 偏好管理
  getPreferences(userId: string): Promise<UserPreferences>
  updatePreferences(userId: string, updates: Partial<UserPreferences>): Promise<void>
  resetPreferences(userId: string): Promise<void>

  // 行为模式
  addPattern(userId: string, pattern: Omit<BehaviorPattern, 'id'>): Promise<string>
  getPatterns(userId: string): Promise<BehaviorPattern[]>
  updatePattern(userId: string, patternId: string, updates: Partial<BehaviorPattern>): Promise<void>
  deletePattern(userId: string, patternId: string): Promise<void>

  // 自动提取
  extractFromConversation(userId: string, messages: Message[]): Promise<ExtractedProfile>
  confirmExtraction(userId: string, extractionId: string, confirmed: boolean): Promise<void>
}
```

### 4.4 知识记忆接口

```typescript
interface IKnowledgeMemoryProvider {
  // 生命周期
  initialize(): Promise<void>
  shutdown(): Promise<void>
  healthCheck(): Promise<HealthStatus>

  // 文档管理
  addDocument(userId: string, document: DocumentInput): Promise<string>
  getDocument(userId: string, documentId: string): Promise<KnowledgeDocument | null>
  deleteDocument(userId: string, documentId: string): Promise<void>
  listDocuments(userId: string, options?: ListOptions): Promise<KnowledgeDocument[]>
  getDocumentStatus(userId: string, documentId: string): Promise<DocumentStatus>

  // 索引管理
  indexDocument(userId: string, documentId: string): Promise<void>
  reindexDocument(userId: string, documentId: string): Promise<void>
  reindexAll(userId: string): Promise<void>

  // 向量搜索
  searchSimilar(userId: string, query: string, options?: VectorSearchOptions): Promise<SearchResult[]>
  searchHybrid(userId: string, query: string, options?: HybridSearchOptions): Promise<SearchResult[]>

  // 知识图谱
  addEntity(userId: string, entity: Omit<Entity, 'id'>): Promise<string>
  addRelationship(userId: string, relationship: Omit<Relationship, 'id'>): Promise<string>
  queryGraph(userId: string, query: GraphQuery): Promise<GraphQueryResult>
  getEntityContext(userId: string, entityId: string, depth?: number): Promise<EntityContext>

  // GraphRAG
  getCommunities(userId: string, level?: number): Promise<Community[]>
  answerWithGraph(userId: string, question: string): Promise<GraphAnswer>

  // 对话转知识
  importConversation(userId: string, sessionId: string, messages: Message[]): Promise<string>
}
```

### 4.5 对象存储接口

```typescript
interface IObjectStorageProvider {
  // 生命周期
  initialize(): Promise<void>
  shutdown(): Promise<void>
  healthCheck(): Promise<HealthStatus>

  // 上传下载
  upload(bucket: string, key: string, data: Buffer | Readable, options?: UploadOptions): Promise<string>
  uploadMultipart(bucket: string, key: string, stream: Readable, options?: MultipartOptions): Promise<string>
  download(bucket: string, key: string): Promise<Buffer>
  getStream(bucket: string, key: string): Promise<Readable>
  getSignedUrl(bucket: string, key: string, expiresIn?: number): Promise<string>

  // 文件管理
  delete(bucket: string, key: string): Promise<void>
  deleteMany(bucket: string, keys: string[]): Promise<void>
  exists(bucket: string, key: string): Promise<boolean>
  getMetadata(bucket: string, key: string): Promise<ObjectMetadata>
  list(bucket: string, prefix?: string, options?: ListOptions): Promise<ObjectInfo[]>

  // 存储桶管理
  createBucket(bucket: string): Promise<void>
  deleteBucket(bucket: string): Promise<void>
  bucketExists(bucket: string): Promise<boolean>
  listBuckets(): Promise<BucketInfo[]>

  // 统计
  getStorageUsage(bucket: string, prefix?: string): Promise<StorageUsage>
}
```

---

## 5. 数据需求

### 5.1 数据模型

#### 5.1.1 工作记忆数据

```typescript
interface WorkingMemory {
  sessionId: string           // 会话 ID (uuidv7)
  userId: string              // 用户 ID
  messages: Message[]         // 对话消息
  contextWindow: number       // 上下文窗口大小
  activeTools: ToolState[]    // 正在执行的工具
  pendingConfirms: PendingConfirm[]  // 待确认操作
  variables: Record<string, unknown>  // 临时变量
  createdAt: Date
  lastActiveAt: Date
  ttl: number                 // 超时时间 (毫秒)
}

interface Message {
  id: string
  role: 'user' | 'assistant' | 'system' | 'tool'
  content: string
  toolCalls?: ToolCall[]
  toolResult?: ToolResult
  metadata?: Record<string, unknown>
  createdAt: Date
}
```

#### 5.1.2 情节记忆数据

```typescript
interface ConversationSummary {
  id: string
  sessionId: string
  summary: string
  keyTopics: string[]
  decisions: string[]
  messageCount: number
  tokenCount: number
  timestamp: Date
}

interface KeyEvent {
  id: string
  type: 'task_completed' | 'preference_changed' | 'important_info' | 'milestone' | 'decision'
  description: string
  context: string
  importance: number         // 0-1
  relatedSessions: string[]
  timestamp: Date
}

interface EmotionalRecord {
  sessionId: string
  sentiment: 'positive' | 'neutral' | 'negative'
  satisfaction: number       // 0-1
  frustration: number        // 0-1
  timestamp: Date
}
```

#### 5.1.3 画像记忆数据

```typescript
interface UserFact {
  id: string
  category: 'personal' | 'work' | 'hobby' | 'skill' | 'relationship' | 'health' | 'finance' | 'other'
  key: string
  value: string
  confidence: number         // 0-1
  source: 'explicit' | 'inferred'
  extractedFrom?: string     // 来源会话 ID
  sensitive: boolean         // 是否敏感
  createdAt: Date
  updatedAt: Date
  validUntil?: Date         // 有效期
}

interface UserPreferences {
  language: string
  timezone: string
  responseStyle: 'concise' | 'detailed' | 'casual' | 'formal'
  confirmLevel: 'low' | 'medium' | 'high'
  favoriteSkills: string[]
  disabledSkills: string[]
  thinkingLevel: 'low' | 'medium' | 'high'
  verboseLevel: 'minimal' | 'normal' | 'verbose'
}

interface BehaviorPattern {
  id: string
  type: 'time_preference' | 'topic_interest' | 'work_style' | 'communication'
  pattern: string
  evidence: string[]
  confidence: number
  updatedAt: Date
}
```

#### 5.1.4 知识记忆数据

```typescript
interface KnowledgeDocument {
  id: string
  title: string
  source: 'upload' | 'conversation' | 'web' | 'integration'
  objectKey: string          // MinIO 对象键
  mimeType: string
  size: number
  status: 'pending' | 'processing' | 'indexed' | 'failed'
  chunks: DocumentChunk[]
  embeddingModel: string
  metadata: Record<string, unknown>
  createdAt: Date
  processedAt?: Date
}

interface Entity {
  id: string
  name: string
  type: string              // person, organization, concept, etc.
  description?: string
  properties: Record<string, unknown>
  createdAt: Date
  updatedAt: Date
}

interface Relationship {
  id: string
  sourceId: string
  targetId: string
  type: string              // works_at, knows, part_of, etc.
  properties: Record<string, unknown>
  weight: number            // 关系强度
  validFrom?: Date
  validUntil?: Date
}
```

### 5.2 存储需求

| 数据类型 | 存储后端 | 容量估算 (每用户) |
|----------|----------|-------------------|
| 工作记忆 | Redis/内存 | ~1MB |
| 情节记忆 | PostgreSQL | ~100MB/年 |
| 画像记忆 | PostgreSQL | ~10MB |
| 向量索引 | Milvus | ~1GB (按文档量) |
| 知识图谱 | Neo4j | ~500MB (按实体量) |
| 多媒体文件 | MinIO | ~10GB (按使用量) |

---

## 6. 安全需求

### 6.1 数据安全

| 需求 ID | 描述 | 优先级 |
|---------|------|--------|
| SEC-01 | 敏感数据加密存储 (AES-256) | P0 |
| SEC-02 | 数据传输 TLS 加密 | P0 |
| SEC-03 | 用户数据隔离 | P0 |
| SEC-04 | 访问审计日志 | P1 |
| SEC-05 | 数据脱敏展示 | P1 |

### 6.2 访问控制

| 需求 ID | 描述 | 优先级 |
|---------|------|--------|
| SEC-06 | 基于角色的访问控制 (RBAC) | P0 |
| SEC-07 | API 认证 (JWT) | P0 |
| SEC-08 | 细粒度权限控制 | P1 |
| SEC-09 | 速率限制 | P1 |

### 6.3 隐私合规

| 需求 ID | 描述 | 优先级 |
|---------|------|--------|
| SEC-10 | 用户数据导出 (GDPR) | P1 |
| SEC-11 | 用户数据删除 ("被遗忘权") | P1 |
| SEC-12 | 敏感信息分级 | P1 |
| SEC-13 | 同意管理 | P2 |

---

## 7. 性能需求

### 7.1 延迟要求

| 操作 | 目标延迟 | 最大延迟 |
|------|----------|----------|
| 消息追加 (工作记忆) | < 50ms | < 100ms |
| 搜索 (情节记忆) | < 200ms | < 500ms |
| 事实查询 (画像记忆) | < 100ms | < 200ms |
| 向量搜索 (知识记忆) | < 300ms | < 1s |
| 图谱查询 (知识记忆) | < 500ms | < 2s |
| 文件上传 (10MB) | < 5s | < 10s |

### 7.2 吞吐量要求

| 指标 | 要求 |
|------|------|
| 并发用户 | 1000+ |
| 每秒消息 | 10000+ |
| 每秒搜索 | 1000+ |
| 每日文档处理 | 10000+ |

### 7.3 可用性要求

| 指标 | 要求 |
|------|------|
| 可用性 SLA | 99.9% |
| 计划内维护窗口 | < 4h/月 |
| 数据持久性 | 99.999999% |
| 故障恢复时间 (RTO) | < 1h |
| 数据恢复点 (RPO) | < 5min |

---

## 8. 验收标准

### 8.1 功能验收

| 测试类别 | 验收标准 |
|----------|----------|
| 工作记忆 | 会话创建/消息追加/上下文获取正常工作 |
| 情节记忆 | 对话摘要生成准确，搜索结果相关 |
| 画像记忆 | 事实提取正确，偏好应用有效 |
| 知识记忆 | 文档索引成功，问答引用正确 |
| 多媒体存储 | 上传下载正常，预览生成正确 |
| 可插拔架构 | 可动态切换提供者实现 |

### 8.2 性能验收

| 测试场景 | 验收标准 |
|----------|----------|
| 负载测试 | 1000 并发用户下延迟 < 目标值 |
| 压力测试 | 峰值负载下系统稳定 |
| 耐久测试 | 24 小时持续运行无内存泄漏 |

### 8.3 安全验收

| 测试类别 | 验收标准 |
|----------|----------|
| 渗透测试 | 无高危/严重漏洞 |
| 数据隔离 | 用户间数据完全隔离 |
| 审计日志 | 关键操作可追溯 |

---

## 9. 附录

### 9.1 参考项目

| 项目 | 地址 | 说明 |
|------|------|------|
| Mem0 | https://github.com/mem0ai/mem0 | 主要记忆后端 |
| Graphiti | https://github.com/getzep/graphiti | 时态知识图谱 |
| Milvus | https://milvus.io | 向量数据库 |
| MinIO | https://min.io | 对象存储 |

### 9.2 现有代码参考

| 文件 | 说明 |
|------|------|
| src/config/sessions/types.ts | 现有会话类型定义 |
| src/memory/manager.ts | 现有记忆管理器 |
| src/memory/embeddings.ts | 现有嵌入实现 |
| src/media/store.ts | 现有媒体存储 |

### 9.3 相关文档

| 文档 | 说明 |
|------|------|
| 05-用户管理系统设计.md | 用户系统设计 |
| 03-技术方案文档.md | 整体技术方案 |
| 02-需求设计文档.md | 平台需求设计 |

---

*— 文档结束 —*
