# OpenClaw AI 个人助理平台 - 记忆与存储系统设计

> 版本: 1.0 | 创建日期: 2026-02-08 | 状态: 整合版
>
> 本文档整合记忆系统架构、技术实现和多媒体存储设计

---

## 修订记录

| 版本 | 日期 | 修订内容 |
|------|------|----------|
| 1.0 | 2026-02-08 | 整合 06-记忆与多媒体系统设计.md、07-记忆系统技术设计.md |

---

## 1. 概述

### 1.1 背景

AI 个人助理需要具备"记忆"能力，以提供个性化、连贯的服务体验。本文档设计完整的记忆系统架构，包括：

- 四层记忆架构（工作记忆、情景记忆、档案记忆、知识记忆）
- 多媒体文件存储（MinIO 对象存储）
- 记忆提供者抽象（Mem0、Graphiti 等）

### 1.2 设计目标

| 目标 | 描述 |
|------|------|
| 个性化服务 | 记住用户偏好、习惯，提供定制化响应 |
| 上下文连贯 | 跨会话保持对话连贯性 |
| 知识积累 | 学习用户领域知识，提升专业能力 |
| 隐私保护 | 用户数据加密存储，支持选择性遗忘 |

---

## 2. 记忆系统架构

### 2.1 四层记忆模型

```
┌─────────────────────────────────────────────────────────────────┐
│                      记忆系统架构                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   工作记忆 (Working Memory)              │   │
│  │  • 当前会话上下文                                        │   │
│  │  • 短期任务状态                                          │   │
│  │  • 实时交互数据                                          │   │
│  │  存储: Redis / 内存                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   情景记忆 (Episodic Memory)             │   │
│  │  • 历史对话记录                                          │   │
│  │  • 任务执行历史                                          │   │
│  │  • 时间线事件                                            │   │
│  │  存储: PostgreSQL + 向量数据库                           │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   档案记忆 (Profile Memory)              │   │
│  │  • 用户偏好设置                                          │   │
│  │  • 个人信息档案                                          │   │
│  │  • 行为模式分析                                          │   │
│  │  存储: PostgreSQL                                        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ↓                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   知识记忆 (Knowledge Memory)            │   │
│  │  • 领域知识图谱                                          │   │
│  │  • 实体关系网络                                          │   │
│  │  • 概念语义理解                                          │   │
│  │  存储: Neo4j 图数据库                                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 记忆层级详解

| 层级 | 名称 | 存储周期 | 数据类型 | 技术选型 |
|------|------|----------|----------|----------|
| L1 | 工作记忆 | 会话级 | 当前上下文、临时状态 | Redis / 内存 |
| L2 | 情景记忆 | 长期 | 对话历史、事件时间线 | PostgreSQL + Milvus |
| L3 | 档案记忆 | 永久 | 用户档案、偏好设置 | PostgreSQL |
| L4 | 知识记忆 | 永久 | 知识图谱、实体关系 | Neo4j |

---

## 3. 技术选型

### 3.1 记忆提供者

| 提供者 | 用途 | 特点 |
|--------|------|------|
| Mem0 | 工作记忆、情景记忆 | 开源、易集成、支持向量检索 |
| Graphiti | 知识记忆 | 知识图谱、实体关系、时序推理 |
| Milvus | 向量存储 | 高性能向量检索、相似度搜索 |
| Neo4j | 图数据库 | 知识图谱存储、关系查询 |

### 3.2 存储技术栈

```
┌─────────────────────────────────────────────────────────────────┐
│                      存储技术栈                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │   Redis      │  │  PostgreSQL  │  │    Milvus    │          │
│  │  工作记忆    │  │  结构化数据  │  │  向量检索    │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │    Neo4j     │  │    MinIO     │  │   Embedding  │          │
│  │  知识图谱    │  │  对象存储    │  │  向量化服务  │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. 记忆提供者接口设计

### 4.1 基础接口

```typescript
/**
 * 记忆提供者基础接口
 */
interface MemoryProvider {
  /** 提供者名称 */
  readonly name: string;

  /** 初始化提供者 */
  initialize(): Promise<void>;

  /** 关闭提供者 */
  shutdown(): Promise<void>;

  /** 健康检查 */
  healthCheck(): Promise<boolean>;
}

/**
 * 工作记忆提供者接口
 */
interface WorkingMemoryProvider extends MemoryProvider {
  /** 获取当前会话上下文 */
  getContext(sessionId: string): Promise<SessionContext>;

  /** 更新会话上下文 */
  updateContext(sessionId: string, context: Partial<SessionContext>): Promise<void>;

  /** 清除会话上下文 */
  clearContext(sessionId: string): Promise<void>;

  /** 添加消息到上下文 */
  addMessage(sessionId: string, message: Message): Promise<void>;

  /** 获取最近消息 */
  getRecentMessages(sessionId: string, limit?: number): Promise<Message[]>;
}

/**
 * 情景记忆提供者接口
 */
interface EpisodicMemoryProvider extends MemoryProvider {
  /** 存储记忆 */
  store(memory: EpisodicMemory): Promise<string>;

  /** 检索相关记忆 */
  retrieve(query: string, options?: RetrieveOptions): Promise<EpisodicMemory[]>;

  /** 按时间范围查询 */
  queryByTimeRange(start: Date, end: Date): Promise<EpisodicMemory[]>;

  /** 删除记忆 */
  delete(memoryId: string): Promise<void>;
}

/**
 * 档案记忆提供者接口
 */
interface ProfileMemoryProvider extends MemoryProvider {
  /** 获取用户档案 */
  getProfile(userId: string): Promise<UserProfile>;

  /** 更新用户档案 */
  updateProfile(userId: string, profile: Partial<UserProfile>): Promise<void>;

  /** 获取用户偏好 */
  getPreferences(userId: string): Promise<UserPreferences>;

  /** 更新用户偏好 */
  updatePreferences(userId: string, prefs: Partial<UserPreferences>): Promise<void>;
}

/**
 * 知识记忆提供者接口
 */
interface KnowledgeMemoryProvider extends MemoryProvider {
  /** 添加实体 */
  addEntity(entity: Entity): Promise<string>;

  /** 添加关系 */
  addRelation(relation: Relation): Promise<string>;

  /** 查询实体 */
  queryEntities(query: EntityQuery): Promise<Entity[]>;

  /** 查询关系 */
  queryRelations(entityId: string): Promise<Relation[]>;

  /** 图遍历查询 */
  traverse(startId: string, depth: number): Promise<GraphResult>;
}
```

### 4.2 数据类型定义

```typescript
/**
 * 会话上下文
 */
interface SessionContext {
  sessionId: string;
  userId: string;
  deviceId: string;
  messages: Message[];
  metadata: Record<string, unknown>;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * 情景记忆
 */
interface EpisodicMemory {
  id: string;
  userId: string;
  type: 'conversation' | 'task' | 'event';
  content: string;
  embedding?: number[];
  metadata: {
    sessionId?: string;
    taskId?: string;
    importance?: number;
    emotions?: string[];
  };
  timestamp: Date;
}

/**
 * 用户档案
 */
interface UserProfile {
  userId: string;
  displayName: string;
  bio?: string;
  interests: string[];
  skills: string[];
  workPatterns: {
    activeHours: string[];
    preferredLanguage: string;
    communicationStyle: string;
  };
  updatedAt: Date;
}

/**
 * 知识实体
 */
interface Entity {
  id: string;
  type: string;
  name: string;
  properties: Record<string, unknown>;
  embedding?: number[];
  createdAt: Date;
}

/**
 * 知识关系
 */
interface Relation {
  id: string;
  sourceId: string;
  targetId: string;
  type: string;
  properties: Record<string, unknown>;
  weight?: number;
  createdAt: Date;
}
```

---

## 5. 记忆管理器实现

### 5.1 统一管理器

```typescript
/**
 * 记忆管理器 - 统一管理所有记忆层
 */
class MemoryManager {
  private workingMemory: WorkingMemoryProvider;
  private episodicMemory: EpisodicMemoryProvider;
  private profileMemory: ProfileMemoryProvider;
  private knowledgeMemory: KnowledgeMemoryProvider;

  constructor(config: MemoryConfig) {
    this.workingMemory = MemoryProviderFactory.createWorkingMemory(config);
    this.episodicMemory = MemoryProviderFactory.createEpisodicMemory(config);
    this.profileMemory = MemoryProviderFactory.createProfileMemory(config);
    this.knowledgeMemory = MemoryProviderFactory.createKnowledgeMemory(config);
  }

  /**
   * 初始化所有记忆提供者
   */
  async initialize(): Promise<void> {
    await Promise.all([
      this.workingMemory.initialize(),
      this.episodicMemory.initialize(),
      this.profileMemory.initialize(),
      this.knowledgeMemory.initialize(),
    ]);
  }

  /**
   * 处理用户消息 - 更新相关记忆
   */
  async processMessage(sessionId: string, message: Message): Promise<void> {
    // 1. 更新工作记忆
    await this.workingMemory.addMessage(sessionId, message);

    // 2. 存储到情景记忆
    await this.episodicMemory.store({
      id: crypto.randomUUID(),
      userId: message.userId,
      type: 'conversation',
      content: message.content,
      metadata: { sessionId },
      timestamp: new Date(),
    });

    // 3. 提取实体更新知识图谱
    const entities = await this.extractEntities(message.content);
    for (const entity of entities) {
      await this.knowledgeMemory.addEntity(entity);
    }
  }

  /**
   * 获取相关上下文 - 用于 AI 响应
   */
  async getRelevantContext(
    userId: string,
    query: string
  ): Promise<MemoryContext> {
    const [profile, recentMemories, relatedKnowledge] = await Promise.all([
      this.profileMemory.getProfile(userId),
      this.episodicMemory.retrieve(query, { limit: 5 }),
      this.knowledgeMemory.queryEntities({ query, limit: 10 }),
    ]);

    return {
      profile,
      recentMemories,
      relatedKnowledge,
    };
  }
}
```

### 5.2 提供者工厂

```typescript
/**
 * 记忆提供者工厂
 */
class MemoryProviderFactory {
  static createWorkingMemory(config: MemoryConfig): WorkingMemoryProvider {
    switch (config.workingMemory.provider) {
      case 'mem0':
        return new Mem0WorkingMemoryProvider(config.workingMemory);
      case 'redis':
        return new RedisWorkingMemoryProvider(config.workingMemory);
      default:
        return new InMemoryWorkingMemoryProvider();
    }
  }

  static createEpisodicMemory(config: MemoryConfig): EpisodicMemoryProvider {
    switch (config.episodicMemory.provider) {
      case 'mem0':
        return new Mem0EpisodicMemoryProvider(config.episodicMemory);
      case 'milvus':
        return new MilvusEpisodicMemoryProvider(config.episodicMemory);
      default:
        return new PostgresEpisodicMemoryProvider(config.episodicMemory);
    }
  }

  static createKnowledgeMemory(config: MemoryConfig): KnowledgeMemoryProvider {
    switch (config.knowledgeMemory.provider) {
      case 'graphiti':
        return new GraphitiKnowledgeMemoryProvider(config.knowledgeMemory);
      case 'neo4j':
        return new Neo4jKnowledgeMemoryProvider(config.knowledgeMemory);
      default:
        return new InMemoryKnowledgeMemoryProvider();
    }
  }
}
```

---

## 6. 多媒体存储设计

### 6.1 MinIO 对象存储

```
┌─────────────────────────────────────────────────────────────────┐
│                      MinIO 存储架构                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Bucket 结构                           │   │
│  │                                                          │   │
│  │  openclaw-media/                                         │   │
│  │  ├── avatars/           # 用户头像                       │   │
│  │  │   └── {userId}/                                       │   │
│  │  ├── attachments/       # 对话附件                       │   │
│  │  │   └── {userId}/{sessionId}/                           │   │
│  │  ├── skills/            # 技能资源                       │   │
│  │  │   └── {skillId}/                                      │   │
│  │  └── exports/           # 导出文件                       │   │
│  │      └── {userId}/                                       │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 6.2 存储服务接口

```typescript
/**
 * 存储服务接口
 */
interface StorageService {
  /** 上传文件 */
  upload(params: UploadParams): Promise<UploadResult>;

  /** 下载文件 */
  download(key: string): Promise<Buffer>;

  /** 获取预签名 URL */
  getPresignedUrl(key: string, expiresIn?: number): Promise<string>;

  /** 删除文件 */
  delete(key: string): Promise<void>;

  /** 列出文件 */
  list(prefix: string): Promise<FileInfo[]>;
}

interface UploadParams {
  key: string;
  data: Buffer | Readable;
  contentType: string;
  metadata?: Record<string, string>;
}

interface UploadResult {
  key: string;
  url: string;
  size: number;
  etag: string;
}
```

### 6.3 MinIO 配置

```yaml
# config.yaml
storage:
  provider: minio
  minio:
    endpoint: localhost
    port: 9000
    useSSL: false
    accessKey: ${MINIO_ACCESS_KEY}
    secretKey: ${MINIO_SECRET_KEY}
    bucket: openclaw-media
    region: us-east-1

  # 文件限制
  limits:
    maxFileSize: 104857600  # 100MB
    allowedTypes:
      - image/jpeg
      - image/png
      - image/gif
      - application/pdf
      - text/plain
```

---

## 7. 记忆 API 设计

### 7.1 RPC 方法

```typescript
// 记忆相关 RPC 方法
const memoryMethods = {
  // 工作记忆
  'memory.getContext': handleGetContext,
  'memory.updateContext': handleUpdateContext,
  'memory.clearContext': handleClearContext,

  // 情景记忆
  'memory.store': handleStoreMemory,
  'memory.retrieve': handleRetrieveMemory,
  'memory.search': handleSearchMemory,
  'memory.delete': handleDeleteMemory,

  // 档案记忆
  'memory.getProfile': handleGetProfile,
  'memory.updateProfile': handleUpdateProfile,
  'memory.getPreferences': handleGetPreferences,
  'memory.updatePreferences': handleUpdatePreferences,

  // 知识记忆
  'memory.addEntity': handleAddEntity,
  'memory.queryEntities': handleQueryEntities,
  'memory.addRelation': handleAddRelation,
  'memory.queryRelations': handleQueryRelations,
};
```

### 7.2 API 示例

#### 检索相关记忆

```
POST /api/v1/memory/retrieve

请求体:
{
  "query": "上次讨论的项目进度",
  "options": {
    "limit": 5,
    "timeRange": {
      "start": "2026-01-01T00:00:00Z",
      "end": "2026-02-08T00:00:00Z"
    }
  }
}

响应:
{
  "success": true,
  "data": {
    "memories": [
      {
        "id": "uuid",
        "type": "conversation",
        "content": "项目进度已完成 80%...",
        "relevance": 0.92,
        "timestamp": "2026-02-05T10:30:00Z"
      }
    ]
  }
}
```

#### 更新用户偏好

```
PATCH /api/v1/memory/preferences

请求体:
{
  "language": "zh-CN",
  "timezone": "Asia/Shanghai",
  "notificationEnabled": true,
  "theme": "dark"
}

响应:
{
  "success": true,
  "data": {
    "preferences": { ... }
  }
}
```

---

## 8. 隐私与安全

### 8.1 数据加密

- 敏感记忆内容使用 AES-256 加密存储
- 向量嵌入不可逆，保护原始内容
- 传输层使用 TLS 1.3

### 8.2 选择性遗忘

```typescript
/**
 * 遗忘策略
 */
interface ForgetPolicy {
  /** 自动过期时间 */
  autoExpire?: {
    workingMemory: number;  // 默认 24 小时
    episodicMemory: number; // 默认 90 天
  };

  /** 敏感信息过滤 */
  sensitivePatterns: RegExp[];

  /** 用户主动遗忘 */
  userForget: {
    enabled: boolean;
    confirmRequired: boolean;
  };
}
```

### 8.3 访问控制

- 记忆数据按用户隔离
- 设备级别的记忆访问权限
- 审计日志记录所有记忆访问

---

## 9. 部署配置

### 9.1 Docker Compose

```yaml
version: '3.8'

services:
  minio:
    image: minio/minio:latest
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ACCESS_KEY}
      MINIO_ROOT_PASSWORD: ${MINIO_SECRET_KEY}
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"

  milvus:
    image: milvusdb/milvus:latest
    ports:
      - "19530:19530"
    volumes:
      - milvus_data:/var/lib/milvus

  neo4j:
    image: neo4j:5
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      NEO4J_AUTH: neo4j/${NEO4J_PASSWORD}
    volumes:
      - neo4j_data:/data

volumes:
  minio_data:
  milvus_data:
  neo4j_data:
```

### 9.2 环境变量

```bash
# .env
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
MINIO_ENDPOINT=localhost:9000

MILVUS_HOST=localhost
MILVUS_PORT=19530

NEO4J_URI=bolt://localhost:7687
NEO4J_USER=neo4j
NEO4J_PASSWORD=password

MEM0_API_KEY=your-api-key
GRAPHITI_API_KEY=your-api-key
```

---

*— 文档结束 —*
