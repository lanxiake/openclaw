# 10e - 基础设施部署方案

> 版本: 1.0 | 创建日期: 2026-02-12 | 状态: 规划中
>
> 上级文档: [10-多租户架构改造总体方案.md](./10-多租户架构改造总体方案.md)
>
> 参考文档: [03-记忆与存储系统设计.md](./03-记忆与存储系统设计.md)

---

## 1. 概述

### 1.1 目标

为多租户平台引入必要的基础设施组件：Redis、MinIO、向量检索，并通过 Docker Compose 统一编排部署。

### 1.2 基础设施总览

| 组件       | 用途                              | 初期方案        | 演进方案           |
| ---------- | --------------------------------- | --------------- | ------------------ |
| PostgreSQL | 结构化数据存储                    | 已有，继续使用  | 按需分库           |
| Redis      | 缓存 + 会话 + 事件总线 + 限流     | 单实例          | Sentinel / Cluster |
| MinIO      | 对象存储（文件/附件/技能包/头像） | 单实例          | 分布式             |
| pgvector   | 向量检索（记忆语义搜索）          | PostgreSQL 扩展 | 独立 Milvus        |

---

## 2. Redis 设计

### 2.1 用途场景

| 场景              | Key 模式                       | 数据类型 | TTL              |
| ----------------- | ------------------------------ | -------- | ---------------- |
| 用户 Session 缓存 | `session:{userId}:{sessionId}` | Hash     | 24h              |
| 用户配额缓存      | `quota:{userId}:{quotaType}`   | String   | 5min             |
| Token 黑名单      | `blacklist:{tokenHash}`        | String   | Token 剩余有效期 |
| 验证码            | `code:{type}:{identifier}`     | String   | 5min             |
| 限流计数器        | `ratelimit:{ip}:{endpoint}`    | String   | 窗口期           |
| 在线设备状态      | `device:{userId}:{deviceId}`   | Hash     | 心跳间隔 ×3      |
| 分布式锁          | `lock:{resource}`              | String   | 30s              |
| Pub/Sub 事件通道  | `openclaw:*`                   | Channel  | -                |

### 2.2 Session 缓存设计

```typescript
// src/infrastructure/redis/session-cache.ts

/**
 * Redis Session 缓存
 *
 * 作为 PostgreSQL Session 表的缓存层，
 * 减少数据库查询压力
 */
export class SessionCache {
  private readonly prefix = "session";
  private readonly ttl = 86400; // 24 小时

  /**
   * 缓存 Session
   */
  async set(userId: string, sessionId: string, data: SessionData): Promise<void> {
    const key = `${this.prefix}:${userId}:${sessionId}`;
    await redis.hset(key, this.serialize(data));
    await redis.expire(key, this.ttl);
  }

  /**
   * 读取 Session（缓存 miss 时回源数据库）
   */
  async get(userId: string, sessionId: string): Promise<SessionData | null> {
    const key = `${this.prefix}:${userId}:${sessionId}`;
    const cached = await redis.hgetall(key);

    if (Object.keys(cached).length > 0) {
      return this.deserialize(cached);
    }

    // 回源数据库
    const dbData = await sessionRepo.findById(sessionId, userId);
    if (dbData) {
      await this.set(userId, sessionId, dbData);
    }
    return dbData;
  }

  /**
   * 删除 Session 缓存（密码修改/强制登出时调用）
   */
  async invalidate(userId: string, sessionId?: string): Promise<void> {
    if (sessionId) {
      await redis.del(`${this.prefix}:${userId}:${sessionId}`);
    } else {
      // 批量删除用户所有 Session
      const keys = await redis.keys(`${this.prefix}:${userId}:*`);
      if (keys.length > 0) {
        await redis.del(...keys);
      }
    }
  }
}
```

### 2.3 配额缓存设计

```typescript
// src/infrastructure/redis/quota-cache.ts

/**
 * 配额缓存
 *
 * 将用户配额的 usedValue 缓存到 Redis，
 * Agent 调用前快速检查，避免频繁查库
 */
export class QuotaCache {
  private readonly prefix = "quota";
  private readonly ttl = 300; // 5 分钟

  /**
   * 获取剩余配额（缓存优先）
   */
  async getRemaining(userId: string, quotaType: string): Promise<number> {
    const key = `${this.prefix}:${userId}:${quotaType}`;
    const cached = await redis.get(key);

    if (cached !== null) {
      return parseInt(cached, 10);
    }

    // 回源数据库
    const quota = await usageQuotaRepo.findCurrent(userId, quotaType);
    const remaining = quota ? quota.limitValue - quota.usedValue : 0;
    await redis.setex(key, this.ttl, remaining.toString());
    return remaining;
  }

  /**
   * 扣减配额（Redis 原子递减 + 异步写库）
   */
  async decrement(userId: string, quotaType: string, amount: number): Promise<number> {
    const key = `${this.prefix}:${userId}:${quotaType}`;
    const remaining = await redis.decrby(key, amount);

    // 异步写回数据库
    void usageQuotaRepo.incrementUsage(userId, quotaType, amount);

    return remaining;
  }
}
```

### 2.4 Pub/Sub 事件通道

> 参考 10c-AppServer设计方案.md §6.2

```typescript
// src/infrastructure/redis/pubsub.ts

/**
 * Redis Pub/Sub 事件总线
 *
 * 用于 App Server → Gateway 的异步事件通知
 */
export class EventBus {
  private subscriber: Redis;
  private publisher: Redis;

  /**
   * 发布事件
   */
  async publish(channel: string, message: PubSubMessage): Promise<void> {
    await this.publisher.publish(channel, JSON.stringify(message));
    log.debug(`[EventBus] Published to ${channel}`, { userId: message.userId });
  }

  /**
   * 订阅事件
   */
  async subscribe(channel: string, handler: (msg: PubSubMessage) => void): Promise<void> {
    await this.subscriber.subscribe(channel);
    this.subscriber.on("message", (ch, data) => {
      if (ch === channel) {
        handler(JSON.parse(data));
      }
    });
    log.info(`[EventBus] Subscribed to ${channel}`);
  }
}

/** 事件通道定义 */
export const EventChannels = {
  CONFIG_CHANGED: "openclaw:config:changed",
  SKILL_SYNCED: "openclaw:skill:synced",
  USER_SUSPENDED: "openclaw:user:suspended",
  QUOTA_EXHAUSTED: "openclaw:quota:exhausted",
} as const;
```

---

## 3. MinIO 对象存储设计

### 3.1 Bucket 架构

> 参考 03-记忆与存储系统设计.md §6.1

```
openclaw-media/                     # 主 bucket
├── {userId}/
│   ├── avatars/                    # 用户头像
│   │   └── {timestamp}_{hash}.jpg
│   ├── attachments/                # 对话附件
│   │   └── {conversationId}/
│   │       └── {messageId}_{filename}
│   ├── documents/                  # 文档
│   │   └── {fileId}_{filename}
│   └── skills/                     # 自建技能包
│       └── {skillId}/
│           └── {version}/
│               └── package.zip
├── system/
│   ├── skill-icons/                # 技能商店图标
│   └── default-avatars/            # 系统默认头像
└── exports/
    └── {userId}/                   # 数据导出文件
        └── {exportId}.zip
```

### 3.2 文件服务层

```typescript
// src/infrastructure/minio/file-service.ts

/**
 * MinIO 文件服务
 *
 * 提供文件上传、下载、删除和 presigned URL 功能
 */
export class FileService {
  private readonly client: Minio.Client;
  private readonly bucket = "openclaw-media";

  /**
   * 上传文件
   *
   * @returns storageKey（MinIO 中的对象路径）
   */
  async upload(params: {
    userId: string;
    category: "avatar" | "attachment" | "document" | "skill";
    fileName: string;
    content: Buffer | Readable;
    contentType: string;
    sourceId?: string;
  }): Promise<{ storageKey: string; checksum: string }> {
    const { userId, category, fileName, content, contentType, sourceId } = params;

    // 构建存储路径
    const storageKey = this.buildStorageKey(userId, category, fileName, sourceId);

    // 计算 SHA-256
    const checksum = await this.computeChecksum(content);

    // 上传到 MinIO
    await this.client.putObject(this.bucket, storageKey, content, {
      "Content-Type": contentType,
      "x-amz-meta-user-id": userId,
      "x-amz-meta-checksum": checksum,
    });

    log.info(`[FileService] Uploaded ${storageKey}`, { userId, category });
    return { storageKey, checksum };
  }

  /**
   * 生成临时下载链接（有效期 1 小时）
   */
  async getPresignedUrl(storageKey: string, expiry: number = 3600): Promise<string> {
    return this.client.presignedGetObject(this.bucket, storageKey, expiry);
  }

  /**
   * 删除文件
   */
  async delete(storageKey: string): Promise<void> {
    await this.client.removeObject(this.bucket, storageKey);
    log.info(`[FileService] Deleted ${storageKey}`);
  }

  /**
   * 构建存储路径
   */
  private buildStorageKey(
    userId: string,
    category: string,
    fileName: string,
    sourceId?: string,
  ): string {
    const sanitized = this.sanitizeFileName(fileName);
    const timestamp = Date.now();

    switch (category) {
      case "avatar":
        return `${userId}/avatars/${timestamp}_${sanitized}`;
      case "attachment":
        return `${userId}/attachments/${sourceId ?? "unknown"}/${timestamp}_${sanitized}`;
      case "document":
        return `${userId}/documents/${timestamp}_${sanitized}`;
      case "skill":
        return `${userId}/skills/${sourceId ?? "unknown"}/${sanitized}`;
      default:
        return `${userId}/misc/${timestamp}_${sanitized}`;
    }
  }
}
```

### 3.3 文件大小限制

| 文件类型 | 最大大小 | MIME 类型限制                     |
| -------- | -------- | --------------------------------- |
| 头像     | 5 MB     | image/jpeg, image/png, image/webp |
| 对话附件 | 50 MB    | 图片/音频/视频/PDF/Office         |
| 文档     | 100 MB   | PDF/Office/TXT/Markdown           |
| 技能包   | 50 MB    | application/zip                   |
| 数据导出 | 500 MB   | application/zip                   |

### 3.4 存储配额管理

```typescript
/**
 * 检查用户存储配额
 *
 * @returns 是否允许上传
 */
async function checkStorageQuota(
  userId: string,
  fileSizeBytes: number,
): Promise<{ allowed: boolean; reason?: string }> {
  const quota = await quotaCache.getRemaining(userId, "storage");
  const fileSizeMb = fileSizeBytes / (1024 * 1024);

  if (quota < fileSizeMb) {
    return {
      allowed: false,
      reason: `存储配额不足，剩余 ${quota.toFixed(1)} MB，文件大小 ${fileSizeMb.toFixed(1)} MB`,
    };
  }

  return { allowed: true };
}
```

---

## 4. 向量检索设计

### 4.1 初期方案：pgvector

> 参考 03-记忆与存储系统设计.md §3.3

使用 PostgreSQL pgvector 扩展实现记忆语义搜索，避免引入额外服务。

#### 启用 pgvector

```sql
-- PostgreSQL 启用 pgvector 扩展
CREATE EXTENSION IF NOT EXISTS vector;

-- 将 user_memories.embedding 从 jsonb 改为 vector 类型
ALTER TABLE user_memories
  ADD COLUMN embedding_vec vector(1536);

-- 创建 HNSW 索引（高性能近似搜索）
CREATE INDEX user_memories_embedding_idx
  ON user_memories
  USING hnsw (embedding_vec vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);
```

#### Drizzle Schema 更新

```typescript
// src/db/schema/memories.ts — Phase 5 更新

import { vector } from "drizzle-orm/pg-core";

export const userMemories = pgTable("user_memories", {
  // ... 现有字段 ...

  // Phase 5: jsonb → vector 迁移
  embeddingVec: vector("embedding_vec", { dimensions: 1536 }),
});
```

### 4.2 语义搜索实现

```typescript
// src/infrastructure/vector/memory-search.ts

/**
 * 记忆语义搜索服务
 *
 * 使用 pgvector 实现基于向量余弦相似度的记忆检索
 */
export class MemorySearchService {
  /**
   * 语义搜索用户记忆
   *
   * @param userId - 用户 ID
   * @param queryEmbedding - 查询向量（由 AI 模型生成）
   * @param options - 搜索选项
   */
  async search(params: {
    userId: string;
    queryEmbedding: number[];
    limit?: number;
    minSimilarity?: number;
    types?: MemoryType[];
  }): Promise<MemorySearchResult[]> {
    const { userId, queryEmbedding, limit = 10, minSimilarity = 0.7, types } = params;

    // 构建 SQL 查询
    const results = await db.execute(sql`
      SELECT
        id, type, category, content, summary, importance,
        1 - (embedding_vec <=> ${JSON.stringify(queryEmbedding)}::vector) as similarity
      FROM user_memories
      WHERE user_id = ${userId}
        AND is_active = true
        AND (expires_at IS NULL OR expires_at > NOW())
        ${types ? sql`AND type = ANY(${types})` : sql``}
      ORDER BY embedding_vec <=> ${JSON.stringify(queryEmbedding)}::vector
      LIMIT ${limit}
    `);

    return results
      .filter((r) => r.similarity >= minSimilarity)
      .map((r) => ({
        ...r,
        similarity: parseFloat(r.similarity),
      }));
  }

  /**
   * 生成文本向量嵌入
   *
   * 调用 OpenAI Embeddings API
   */
  async generateEmbedding(text: string): Promise<number[]> {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: text,
    });
    return response.data[0].embedding;
  }
}
```

### 4.3 演进方案：Milvus

当数据量超过百万级记忆条目，且 pgvector 性能不足时，迁移到独立 Milvus 实例：

| 指标       | pgvector              | Milvus             |
| ---------- | --------------------- | ------------------ |
| 适用数据量 | < 100 万向量          | > 100 万向量       |
| 查询延迟   | 10-50ms               | 1-10ms             |
| 内存占用   | 与 PostgreSQL 共享    | 独立管理           |
| 运维复杂度 | 低（PostgreSQL 扩展） | 高（独立服务）     |
| 引入时机   | Phase 5 初期          | 用户规模增长后评估 |

---

## 5. Docker Compose 编排

### 5.1 开发环境

```yaml
# docker-compose.dev.yml

version: "3.8"

services:
  postgres:
    image: pgvector/pgvector:pg16
    container_name: openclaw-postgres
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: openclaw
      POSTGRES_USER: openclaw
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-openclaw_dev}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U openclaw"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: openclaw-redis
    ports:
      - "6379:6379"
    command: redis-server --maxmemory 256mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  minio:
    image: minio/minio:latest
    container_name: openclaw-minio
    ports:
      - "9000:9000" # API
      - "9001:9001" # Web Console
    environment:
      MINIO_ROOT_USER: ${MINIO_ACCESS_KEY:-openclaw}
      MINIO_ROOT_PASSWORD: ${MINIO_SECRET_KEY:-openclaw_dev_secret}
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data
    healthcheck:
      test: ["CMD", "mc", "ready", "local"]
      interval: 10s
      timeout: 5s
      retries: 5

  # MinIO 初始化（创建 bucket）
  minio-init:
    image: minio/mc:latest
    container_name: openclaw-minio-init
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
        mc alias set openclaw http://minio:9000 $${MINIO_ACCESS_KEY:-openclaw} $${MINIO_SECRET_KEY:-openclaw_dev_secret};
        mc mb --ignore-existing openclaw/openclaw-media;
        mc anonymous set download openclaw/openclaw-media/system;
        echo 'MinIO initialized';
      "

volumes:
  postgres_data:
  redis_data:
  minio_data:
```

### 5.2 生产环境

```yaml
# docker-compose.prod.yml

version: "3.8"

services:
  postgres:
    image: pgvector/pgvector:pg16
    container_name: openclaw-postgres
    restart: always
    ports:
      - "127.0.0.1:5432:5432"
    environment:
      POSTGRES_DB: openclaw
      POSTGRES_USER: openclaw
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backup:/backup
    deploy:
      resources:
        limits:
          memory: 2G

  redis:
    image: redis:7-alpine
    container_name: openclaw-redis
    restart: always
    ports:
      - "127.0.0.1:6379:6379"
    command: >
      redis-server
        --maxmemory 512mb
        --maxmemory-policy allkeys-lru
        --appendonly yes
        --appendfsync everysec
        --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    deploy:
      resources:
        limits:
          memory: 768M

  minio:
    image: minio/minio:latest
    container_name: openclaw-minio
    restart: always
    ports:
      - "127.0.0.1:9000:9000"
      - "127.0.0.1:9001:9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ACCESS_KEY}
      MINIO_ROOT_PASSWORD: ${MINIO_SECRET_KEY}
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data
    deploy:
      resources:
        limits:
          memory: 1G

  gateway:
    build:
      context: .
      dockerfile: Dockerfile.gateway
    container_name: openclaw-gateway
    restart: always
    ports:
      - "127.0.0.1:18789:18789"
    environment:
      DATABASE_URL: postgresql://openclaw:${POSTGRES_PASSWORD}@postgres:5432/openclaw
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
      NODE_ENV: production
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  api-server:
    build:
      context: .
      dockerfile: Dockerfile.api-server
    container_name: openclaw-api-server
    restart: always
    ports:
      - "127.0.0.1:3000:3000"
    environment:
      DATABASE_URL: postgresql://openclaw:${POSTGRES_PASSWORD}@postgres:5432/openclaw
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
      MINIO_ENDPOINT: minio
      MINIO_PORT: 9000
      MINIO_ACCESS_KEY: ${MINIO_ACCESS_KEY}
      MINIO_SECRET_KEY: ${MINIO_SECRET_KEY}
      JWT_SECRET: ${JWT_SECRET}
      JWT_ADMIN_SECRET: ${JWT_ADMIN_SECRET}
      NODE_ENV: production
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy

  nginx:
    image: nginx:alpine
    container_name: openclaw-nginx
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./nginx/ssl:/etc/nginx/ssl
      - ./nginx/html:/usr/share/nginx/html
    depends_on:
      - gateway
      - api-server

volumes:
  postgres_data:
  redis_data:
  minio_data:
```

---

## 6. 监控与运维

### 6.1 健康检查端点

```
GET /api/health                → App Server 健康检查
GET /api/health/dependencies   → 依赖服务健康状态

响应示例：
{
  "status": "healthy",
  "version": "1.0.0",
  "uptime": 86400,
  "dependencies": {
    "postgres": { "status": "healthy", "latency": 2 },
    "redis": { "status": "healthy", "latency": 1 },
    "minio": { "status": "healthy", "latency": 3 }
  }
}
```

### 6.2 数据备份

| 组件       | 备份方式               | 频率      | 保留期 |
| ---------- | ---------------------- | --------- | ------ |
| PostgreSQL | `pg_dump` + 定时 cron  | 每日      | 30 天  |
| Redis      | AOF + RDB 快照         | 实时+每时 | 7 天   |
| MinIO      | `mc mirror` 到备份目录 | 每日      | 30 天  |

### 6.3 资源需求估算（初期 100 用户）

| 组件       | CPU         | 内存       | 磁盘      |
| ---------- | ----------- | ---------- | --------- |
| PostgreSQL | 1 核        | 2 GB       | 20 GB     |
| Redis      | 0.5 核      | 512 MB     | 1 GB      |
| MinIO      | 0.5 核      | 1 GB       | 50 GB     |
| Gateway    | 1 核        | 1 GB       | -         |
| App Server | 1 核        | 1 GB       | -         |
| Nginx      | 0.25核      | 128 MB     | -         |
| **合计**   | **4.25 核** | **5.6 GB** | **71 GB** |

---

## 7. 实施步骤

### Step 1: Docker Compose 开发环境

- 创建 `docker-compose.dev.yml`
- 包含 PostgreSQL (pgvector) + Redis + MinIO
- 编写 MinIO 初始化脚本（创建 bucket）
- 验证所有服务健康启动

### Step 2: Redis 集成

- 安装 `ioredis` 依赖
- 创建 `src/infrastructure/redis/` 模块
- 实现 SessionCache + QuotaCache + EventBus
- 单元测试验证缓存读写和 Pub/Sub

### Step 3: MinIO 集成

- 安装 `minio` 依赖
- 创建 `src/infrastructure/minio/` 模块
- 实现 FileService（上传/下载/删除/presigned URL）
- 集成测试验证文件操作

### Step 4: pgvector 启用

- PostgreSQL 启用 vector 扩展
- Drizzle schema 添加 vector 列类型
- 实现 MemorySearchService
- 集成测试验证向量搜索

### Step 5: 生产部署配置

- 创建 `docker-compose.prod.yml`
- 配置 Nginx 反向代理
- 编写 `.env.example` 和部署文档
- 配置备份 cron 任务

---

## 8. 验收标准

| #   | 标准                                     | 验证方式 |
| --- | ---------------------------------------- | -------- |
| 1   | docker-compose up 一键启动所有服务       | 手动验证 |
| 2   | Redis 缓存读写正常，Pub/Sub 事件传递正常 | 集成测试 |
| 3   | MinIO 文件上传/下载/删除正常             | 集成测试 |
| 4   | pgvector 语义搜索返回相关结果            | 集成测试 |
| 5   | 健康检查端点返回所有依赖状态             | 端点测试 |
| 6   | 服务重启后数据不丢失（持久化卷）         | 手动验证 |
| 7   | 生产配置使用环境变量，不含硬编码密码     | 代码审查 |

---

_— 文档结束 —_
