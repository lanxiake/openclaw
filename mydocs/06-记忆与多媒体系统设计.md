# AI 个人助理平台 - 记忆与多媒体系统设计文档

> 版本: 1.0 | 创建日期: 2026-02-07 | 状态: 设计中
>
> 本文档设计可插拔的记忆系统架构和 MinIO 对象存储集成方案

---

## 1. 概述

### 1.1 设计目标

| 目标 | 说明 |
|------|------|
| **四层记忆架构** | 工作记忆、情节记忆、画像记忆、知识记忆 |
| **模块可替换** | 统一接口，支持多种实现后端 |
| **MinIO 集成** | 多媒体文件使用对象存储 |
| **生产级稳定** | 基于成熟开源项目 |

### 1.2 开源项目选型

基于研究分析，推荐以下技术栈：

| 记忆类型 | 推荐方案 | 备选方案 | 说明 |
|----------|----------|----------|------|
| **工作记忆** | Mem0 Session | 自研 Redis | 短期对话上下文 |
| **情节记忆** | Mem0 User | Zep/Graphiti | 长期对话历史 |
| **画像记忆** | Mem0 Agent | 自研 PostgreSQL | 用户事实偏好 |
| **知识记忆** | Graphiti + Milvus | GraphRAG | 知识图谱 + 向量 |
| **对象存储** | MinIO | S3 兼容 | 多媒体文件 |

### 1.3 项目对比总结

| 项目 | Stars | TS 支持 | 优势 | 劣势 |
|------|-------|---------|------|------|
| **Mem0** | 46K+ | ✅ 完整 | 开箱即用，社区活跃 | 知识图谱能力弱 |
| **Zep/Graphiti** | 5K+ | ✅ SDK | 时态追踪强，准确率高 | 部署复杂 |
| **Letta/MemGPT** | 18K+ | ✅ SDK | 自编辑记忆创新 | 架构复杂 |
| **GraphRAG** | 28K+ | ❌ Python | 知识图谱最强 | 无 TS SDK |
| **Cognee** | 6K+ | ❌ API | 30+ 数据源 | 无 TS SDK |

---

## 2. 记忆系统架构

### 2.1 四层记忆模型

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         Memory Layer Architecture                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐             │
│  │  工作记忆       │  │  情节记忆       │  │  画像记忆       │             │
│  │  Working       │  │  Episodic      │  │  Profile       │             │
│  │  Memory        │  │  Memory        │  │  Memory        │             │
│  ├────────────────┤  ├────────────────┤  ├────────────────┤             │
│  │ • 当前对话上下文 │  │ • 对话历史摘要  │  │ • 用户基本信息  │             │
│  │ • 工具调用状态  │  │ • 关键事件时间线│  │ • 偏好设置     │             │
│  │ • 临时变量     │  │ • 情感记录     │  │ • 事实记录     │             │
│  │ TTL: 会话级    │  │ TTL: 永久      │  │ TTL: 永久      │             │
│  └───────┬────────┘  └───────┬────────┘  └───────┬────────┘             │
│          │                   │                   │                       │
│          └───────────────────┼───────────────────┘                       │
│                              │                                           │
│                              ▼                                           │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                        知识记忆 Knowledge Memory                    │  │
│  ├───────────────────────────────────────────────────────────────────┤  │
│  │  ┌─────────────────────┐      ┌─────────────────────────────────┐ │  │
│  │  │    向量存储          │      │       知识图谱                   │ │  │
│  │  │    Vector Store     │◄────►│    Knowledge Graph              │ │  │
│  │  │    (Milvus)         │      │    (Neo4j/FalkorDB)             │ │  │
│  │  ├─────────────────────┤      ├─────────────────────────────────┤ │  │
│  │  │ • 语义相似度搜索    │      │ • 实体关系推理                   │ │  │
│  │  │ • 文档 Embedding    │      │ • 多跳查询                       │ │  │
│  │  │ • 混合检索          │      │ • 社区摘要 (GraphRAG)            │ │  │
│  │  └─────────────────────┘      └─────────────────────────────────┘ │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                          │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │                      MinIO 对象存储层                               │  │
│  ├───────────────────────────────────────────────────────────────────┤  │
│  │  • 原始文档 (PDF, DOCX, etc.)                                     │  │
│  │  • 多媒体文件 (图片、音频、视频)                                    │  │
│  │  • 向量索引快照                                                    │  │
│  │  • 知识图谱导出                                                    │  │
│  └───────────────────────────────────────────────────────────────────┘  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 各层记忆详解

#### 2.2.1 工作记忆 (Working Memory)

**用途**: 当前对话的临时上下文，会话结束后清理

```typescript
interface WorkingMemory {
  sessionId: string
  userId: string

  // 对话上下文
  messages: Message[]           // 当前对话消息
  contextWindow: number         // 上下文窗口大小

  // 临时状态
  activeTools: ToolState[]      // 正在执行的工具
  pendingConfirms: Confirm[]    // 待确认操作
  variables: Record<string, unknown>  // 临时变量

  // 元数据
  createdAt: Date
  lastActiveAt: Date
  ttl: number                   // 超时时间 (默认 30 分钟)
}
```

**存储**: Redis 或 Mem0 Session Memory

#### 2.2.2 情节记忆 (Episodic Memory)

**用途**: 长期对话历史，自动摘要和时间线追踪

```typescript
interface EpisodicMemory {
  userId: string

  // 对话摘要
  conversationSummaries: ConversationSummary[]

  // 关键事件
  keyEvents: KeyEvent[]

  // 情感记录
  emotionalStates: EmotionalRecord[]
}

interface ConversationSummary {
  sessionId: string
  summary: string               // AI 生成的摘要
  keyTopics: string[]           // 主要话题
  decisions: string[]           // 做出的决定
  timestamp: Date
  messageCount: number
  tokenCount: number
}

interface KeyEvent {
  id: string
  type: 'task_completed' | 'preference_changed' | 'important_info' | 'milestone'
  description: string
  context: string               // 相关上下文
  timestamp: Date
  importance: number            // 0-1 重要性分数
  relatedSessions: string[]
}

interface EmotionalRecord {
  sessionId: string
  sentiment: 'positive' | 'neutral' | 'negative'
  satisfaction: number          // 0-1 满意度
  frustration: number           // 0-1 挫败感
  timestamp: Date
}
```

**存储**: Mem0 User Memory 或 Zep

#### 2.2.3 画像记忆 (Profile Memory)

**用途**: 用户事实、偏好、长期特征

```typescript
interface ProfileMemory {
  userId: string

  // 基本信息
  facts: UserFact[]

  // 偏好设置
  preferences: UserPreferences

  // 行为模式
  patterns: BehaviorPattern[]
}

interface UserFact {
  id: string
  category: 'personal' | 'work' | 'hobby' | 'skill' | 'relationship' | 'other'
  key: string                   // 如 "name", "company", "favorite_color"
  value: string
  confidence: number            // 0-1 置信度
  source: 'explicit' | 'inferred'  // 明确告知 or 推断
  extractedFrom?: string        // 来源会话 ID
  createdAt: Date
  updatedAt: Date
  validUntil?: Date             // 有效期 (如生日派对计划)
}

interface UserPreferences {
  // 交互偏好
  language: string
  timezone: string
  responseStyle: 'concise' | 'detailed' | 'casual' | 'formal'
  confirmLevel: 'low' | 'medium' | 'high'

  // 功能偏好
  favoriteSkills: string[]
  disabledSkills: string[]
  notificationSettings: NotificationPreferences

  // AI 行为偏好
  thinkingLevel: 'low' | 'medium' | 'high'
  verboseLevel: 'minimal' | 'normal' | 'verbose'
}

interface BehaviorPattern {
  type: 'time_preference' | 'topic_interest' | 'work_style' | 'communication'
  pattern: string               // 模式描述
  evidence: string[]            // 支撑证据
  confidence: number
  updatedAt: Date
}
```

**存储**: Mem0 Agent Memory 或 PostgreSQL

#### 2.2.4 知识记忆 (Knowledge Memory)

**用途**: 结构化知识、文档库、知识图谱

```typescript
interface KnowledgeMemory {
  userId: string

  // 文档库
  documents: KnowledgeDocument[]

  // 知识图谱
  entities: Entity[]
  relationships: Relationship[]

  // 社区摘要 (GraphRAG)
  communities: Community[]
}

interface KnowledgeDocument {
  id: string
  title: string
  source: 'upload' | 'conversation' | 'web' | 'integration'

  // MinIO 存储
  objectKey: string             // MinIO 对象键
  mimeType: string
  size: number

  // 处理状态
  status: 'pending' | 'processing' | 'indexed' | 'failed'

  // 索引信息
  chunks: DocumentChunk[]
  embeddingModel: string

  // 元数据
  metadata: Record<string, unknown>
  createdAt: Date
  processedAt?: Date
}

interface DocumentChunk {
  id: string
  documentId: string
  content: string
  embedding: number[]           // 向量嵌入
  startOffset: number
  endOffset: number
  metadata: {
    page?: number
    section?: string
    heading?: string
  }
}

interface Entity {
  id: string
  name: string
  type: string                  // person, organization, concept, etc.
  description?: string
  properties: Record<string, unknown>
  mentions: EntityMention[]
  createdAt: Date
  updatedAt: Date
}

interface Relationship {
  id: string
  sourceId: string
  targetId: string
  type: string                  // works_at, knows, part_of, etc.
  properties: Record<string, unknown>
  weight: number                // 关系强度
  validFrom?: Date
  validUntil?: Date
}

interface Community {
  id: string
  level: number                 // 层级
  entities: string[]            // 包含的实体 ID
  summary: string               // AI 生成的摘要
  keyThemes: string[]
  parentCommunityId?: string
}
```

**存储**: Milvus (向量) + Neo4j/FalkorDB (图谱) + MinIO (原始文档)

---

## 3. 可插拔接口设计

### 3.1 统一记忆接口

```typescript
// src/memory/interfaces/memory-provider.ts

/**
 * 记忆提供者基础接口
 * 所有记忆实现必须实现此接口
 */
export interface IMemoryProvider {
  readonly name: string
  readonly version: string

  // 生命周期
  initialize(): Promise<void>
  shutdown(): Promise<void>
  healthCheck(): Promise<HealthStatus>
}

/**
 * 工作记忆接口
 */
export interface IWorkingMemoryProvider extends IMemoryProvider {
  // 会话管理
  createSession(userId: string, options?: SessionOptions): Promise<string>
  getSession(sessionId: string): Promise<WorkingMemory | null>
  updateSession(sessionId: string, updates: Partial<WorkingMemory>): Promise<void>
  deleteSession(sessionId: string): Promise<void>

  // 消息管理
  addMessage(sessionId: string, message: Message): Promise<void>
  getMessages(sessionId: string, limit?: number): Promise<Message[]>
  getContextWindow(sessionId: string, maxTokens: number): Promise<Message[]>

  // 状态管理
  setVariable(sessionId: string, key: string, value: unknown): Promise<void>
  getVariable(sessionId: string, key: string): Promise<unknown>
  clearVariables(sessionId: string): Promise<void>
}

/**
 * 情节记忆接口
 */
export interface IEpisodicMemoryProvider extends IMemoryProvider {
  // 对话摘要
  addConversation(userId: string, sessionId: string, messages: Message[]): Promise<void>
  summarizeConversation(userId: string, sessionId: string): Promise<ConversationSummary>
  getConversationHistory(userId: string, options?: QueryOptions): Promise<ConversationSummary[]>

  // 关键事件
  addKeyEvent(userId: string, event: KeyEvent): Promise<void>
  getKeyEvents(userId: string, options?: EventQueryOptions): Promise<KeyEvent[]>

  // 搜索
  searchEpisodes(userId: string, query: string, options?: SearchOptions): Promise<EpisodeSearchResult[]>

  // 时间线
  getTimeline(userId: string, startDate: Date, endDate: Date): Promise<TimelineEntry[]>
}

/**
 * 画像记忆接口
 */
export interface IProfileMemoryProvider extends IMemoryProvider {
  // 用户事实
  addFact(userId: string, fact: Omit<UserFact, 'id' | 'createdAt'>): Promise<string>
  updateFact(userId: string, factId: string, updates: Partial<UserFact>): Promise<void>
  deleteFact(userId: string, factId: string): Promise<void>
  getFacts(userId: string, category?: string): Promise<UserFact[]>
  searchFacts(userId: string, query: string): Promise<UserFact[]>

  // 偏好
  getPreferences(userId: string): Promise<UserPreferences>
  updatePreferences(userId: string, updates: Partial<UserPreferences>): Promise<void>

  // 行为模式
  addPattern(userId: string, pattern: BehaviorPattern): Promise<void>
  getPatterns(userId: string): Promise<BehaviorPattern[]>

  // 从对话中提取
  extractFromConversation(userId: string, messages: Message[]): Promise<ExtractedProfile>
}

/**
 * 知识记忆接口
 */
export interface IKnowledgeMemoryProvider extends IMemoryProvider {
  // 文档管理
  addDocument(userId: string, document: DocumentInput): Promise<string>
  getDocument(userId: string, documentId: string): Promise<KnowledgeDocument | null>
  deleteDocument(userId: string, documentId: string): Promise<void>
  listDocuments(userId: string, options?: ListOptions): Promise<KnowledgeDocument[]>

  // 索引
  indexDocument(userId: string, documentId: string): Promise<void>
  reindexAll(userId: string): Promise<void>

  // 向量搜索
  searchSimilar(userId: string, query: string, options?: VectorSearchOptions): Promise<SearchResult[]>
  searchHybrid(userId: string, query: string, options?: HybridSearchOptions): Promise<SearchResult[]>

  // 知识图谱
  addEntity(userId: string, entity: Omit<Entity, 'id'>): Promise<string>
  addRelationship(userId: string, relationship: Omit<Relationship, 'id'>): Promise<string>
  queryGraph(userId: string, query: GraphQuery): Promise<GraphQueryResult>
  getEntityContext(userId: string, entityId: string, depth?: number): Promise<EntityContext>

  // GraphRAG
  getCommunities(userId: string, level?: number): Promise<Community[]>
  answerWithGraph(userId: string, question: string): Promise<GraphAnswer>
}

/**
 * 对象存储接口
 */
export interface IObjectStorageProvider extends IMemoryProvider {
  // 上传下载
  upload(bucket: string, key: string, data: Buffer | Readable, options?: UploadOptions): Promise<string>
  download(bucket: string, key: string): Promise<Buffer>
  getStream(bucket: string, key: string): Promise<Readable>
  getSignedUrl(bucket: string, key: string, expiresIn?: number): Promise<string>

  // 管理
  delete(bucket: string, key: string): Promise<void>
  exists(bucket: string, key: string): Promise<boolean>
  getMetadata(bucket: string, key: string): Promise<ObjectMetadata>
  list(bucket: string, prefix?: string): Promise<ObjectInfo[]>

  // Bucket
  createBucket(bucket: string): Promise<void>
  deleteBucket(bucket: string): Promise<void>
  bucketExists(bucket: string): Promise<boolean>
}
```

### 3.2 记忆管理器

```typescript
// src/memory/manager.ts

import { EventEmitter } from 'events'

/**
 * 统一记忆管理器
 * 协调各层记忆的访问和同步
 */
export class MemoryManager extends EventEmitter {
  private workingMemory: IWorkingMemoryProvider
  private episodicMemory: IEpisodicMemoryProvider
  private profileMemory: IProfileMemoryProvider
  private knowledgeMemory: IKnowledgeMemoryProvider
  private objectStorage: IObjectStorageProvider

  constructor(config: MemoryManagerConfig) {
    super()
    this.workingMemory = this.createProvider('working', config.working)
    this.episodicMemory = this.createProvider('episodic', config.episodic)
    this.profileMemory = this.createProvider('profile', config.profile)
    this.knowledgeMemory = this.createProvider('knowledge', config.knowledge)
    this.objectStorage = this.createProvider('storage', config.storage)
  }

  /**
   * 初始化所有记忆提供者
   */
  async initialize(): Promise<void> {
    await Promise.all([
      this.workingMemory.initialize(),
      this.episodicMemory.initialize(),
      this.profileMemory.initialize(),
      this.knowledgeMemory.initialize(),
      this.objectStorage.initialize(),
    ])
    this.emit('initialized')
  }

  /**
   * 为用户创建完整的记忆上下文
   */
  async createUserContext(userId: string, sessionId: string): Promise<MemoryContext> {
    const [session, profile, recentEpisodes] = await Promise.all([
      this.workingMemory.getSession(sessionId),
      this.profileMemory.getPreferences(userId),
      this.episodicMemory.getConversationHistory(userId, { limit: 5 }),
    ])

    return {
      userId,
      sessionId,
      session,
      profile,
      recentEpisodes,

      // 快捷方法
      addMessage: (msg) => this.workingMemory.addMessage(sessionId, msg),
      searchKnowledge: (query) => this.knowledgeMemory.searchHybrid(userId, query),
      getFacts: () => this.profileMemory.getFacts(userId),
    }
  }

  /**
   * 会话结束时的记忆处理
   */
  async onSessionEnd(userId: string, sessionId: string): Promise<void> {
    // 1. 获取会话消息
    const messages = await this.workingMemory.getMessages(sessionId)

    if (messages.length === 0) {
      await this.workingMemory.deleteSession(sessionId)
      return
    }

    // 2. 并行处理
    await Promise.all([
      // 生成对话摘要
      this.episodicMemory.addConversation(userId, sessionId, messages),

      // 提取用户画像
      this.profileMemory.extractFromConversation(userId, messages),

      // 提取知识（如果对话中提到了知识）
      this.extractKnowledgeFromConversation(userId, messages),
    ])

    // 3. 清理工作记忆
    await this.workingMemory.deleteSession(sessionId)

    this.emit('session-processed', { userId, sessionId })
  }

  /**
   * 从对话中提取知识到知识图谱
   */
  private async extractKnowledgeFromConversation(
    userId: string,
    messages: Message[]
  ): Promise<void> {
    // 使用 LLM 提取实体和关系
    const extracted = await this.llmExtractor.extractEntitiesAndRelations(messages)

    for (const entity of extracted.entities) {
      await this.knowledgeMemory.addEntity(userId, entity)
    }

    for (const relation of extracted.relationships) {
      await this.knowledgeMemory.addRelationship(userId, relation)
    }
  }

  /**
   * 处理用户上传的知识文档
   */
  async processKnowledgeDocument(
    userId: string,
    file: Buffer,
    metadata: DocumentMetadata
  ): Promise<string> {
    // 1. 上传到 MinIO
    const objectKey = `knowledge/${userId}/${uuidv7()}/${metadata.filename}`
    await this.objectStorage.upload('documents', objectKey, file, {
      contentType: metadata.mimeType,
      metadata: {
        userId,
        originalName: metadata.filename,
      },
    })

    // 2. 创建文档记录
    const documentId = await this.knowledgeMemory.addDocument(userId, {
      title: metadata.title || metadata.filename,
      source: 'upload',
      objectKey,
      mimeType: metadata.mimeType,
      size: file.length,
      metadata,
    })

    // 3. 异步索引（后台任务）
    this.emit('document-added', { userId, documentId })

    return documentId
  }

  /**
   * 智能搜索 - 跨所有记忆层
   */
  async search(userId: string, query: string, options?: SearchOptions): Promise<UnifiedSearchResult> {
    const [
      facts,
      episodes,
      knowledge,
    ] = await Promise.all([
      this.profileMemory.searchFacts(userId, query),
      this.episodicMemory.searchEpisodes(userId, query, options),
      this.knowledgeMemory.searchHybrid(userId, query, options),
    ])

    // 融合排序
    return this.fuseResults({ facts, episodes, knowledge }, query)
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<HealthReport> {
    const checks = await Promise.allSettled([
      this.workingMemory.healthCheck(),
      this.episodicMemory.healthCheck(),
      this.profileMemory.healthCheck(),
      this.knowledgeMemory.healthCheck(),
      this.objectStorage.healthCheck(),
    ])

    return {
      status: checks.every(c => c.status === 'fulfilled') ? 'healthy' : 'degraded',
      components: {
        workingMemory: checks[0],
        episodicMemory: checks[1],
        profileMemory: checks[2],
        knowledgeMemory: checks[3],
        objectStorage: checks[4],
      },
      timestamp: new Date(),
    }
  }
}
```

### 3.3 提供者工厂

```typescript
// src/memory/providers/factory.ts

/**
 * 记忆提供者工厂
 * 根据配置创建对应的实现
 */
export class MemoryProviderFactory {
  private static providers: Map<string, ProviderConstructor> = new Map()

  /**
   * 注册提供者
   */
  static register(type: string, name: string, constructor: ProviderConstructor): void {
    this.providers.set(`${type}:${name}`, constructor)
  }

  /**
   * 创建提供者实例
   */
  static create<T extends IMemoryProvider>(
    type: MemoryType,
    config: ProviderConfig
  ): T {
    const key = `${type}:${config.provider}`
    const Constructor = this.providers.get(key)

    if (!Constructor) {
      throw new Error(`Unknown memory provider: ${key}`)
    }

    return new Constructor(config.options) as T
  }
}

// 注册内置提供者
MemoryProviderFactory.register('working', 'mem0', Mem0WorkingMemoryProvider)
MemoryProviderFactory.register('working', 'redis', RedisWorkingMemoryProvider)

MemoryProviderFactory.register('episodic', 'mem0', Mem0EpisodicMemoryProvider)
MemoryProviderFactory.register('episodic', 'zep', ZepEpisodicMemoryProvider)

MemoryProviderFactory.register('profile', 'mem0', Mem0ProfileMemoryProvider)
MemoryProviderFactory.register('profile', 'postgres', PostgresProfileMemoryProvider)

MemoryProviderFactory.register('knowledge', 'graphiti', GraphitiKnowledgeProvider)
MemoryProviderFactory.register('knowledge', 'graphrag', GraphRAGKnowledgeProvider)

MemoryProviderFactory.register('storage', 'minio', MinIOStorageProvider)
MemoryProviderFactory.register('storage', 's3', S3StorageProvider)
```

---

## 4. Mem0 集成实现

### 4.1 Mem0 工作记忆提供者

```typescript
// src/memory/providers/mem0/working.ts

import { MemoryClient } from 'mem0ai'

export class Mem0WorkingMemoryProvider implements IWorkingMemoryProvider {
  readonly name = 'mem0-working'
  readonly version = '1.0.0'

  private client: MemoryClient
  private sessions: Map<string, WorkingMemory> = new Map()

  constructor(private config: Mem0Config) {}

  async initialize(): Promise<void> {
    this.client = new MemoryClient({
      apiKey: this.config.apiKey,
      // 或自托管
      baseUrl: this.config.baseUrl,
    })
  }

  async createSession(userId: string, options?: SessionOptions): Promise<string> {
    const sessionId = uuidv7()

    const session: WorkingMemory = {
      sessionId,
      userId,
      messages: [],
      contextWindow: options?.contextWindow ?? 8000,
      activeTools: [],
      pendingConfirms: [],
      variables: {},
      createdAt: new Date(),
      lastActiveAt: new Date(),
      ttl: options?.ttl ?? 30 * 60 * 1000, // 30 分钟
    }

    this.sessions.set(sessionId, session)

    return sessionId
  }

  async addMessage(sessionId: string, message: Message): Promise<void> {
    const session = this.sessions.get(sessionId)
    if (!session) throw new Error('Session not found')

    session.messages.push(message)
    session.lastActiveAt = new Date()

    // 同步到 Mem0 (用于跨设备)
    await this.client.add([
      {
        role: message.role,
        content: message.content,
      }
    ], {
      user_id: session.userId,
      session_id: sessionId,
    })
  }

  async getContextWindow(sessionId: string, maxTokens: number): Promise<Message[]> {
    const session = this.sessions.get(sessionId)
    if (!session) return []

    // 从后往前取消息，直到达到 token 限制
    const result: Message[] = []
    let tokenCount = 0

    for (let i = session.messages.length - 1; i >= 0; i--) {
      const msg = session.messages[i]
      const msgTokens = this.estimateTokens(msg.content)

      if (tokenCount + msgTokens > maxTokens) break

      result.unshift(msg)
      tokenCount += msgTokens
    }

    return result
  }

  // ... 其他方法实现
}
```

### 4.2 Mem0 情节记忆提供者

```typescript
// src/memory/providers/mem0/episodic.ts

export class Mem0EpisodicMemoryProvider implements IEpisodicMemoryProvider {
  readonly name = 'mem0-episodic'
  readonly version = '1.0.0'

  private client: MemoryClient

  async addConversation(
    userId: string,
    sessionId: string,
    messages: Message[]
  ): Promise<void> {
    // Mem0 自动提取关键信息
    await this.client.add(
      messages.map(m => ({
        role: m.role,
        content: m.content,
      })),
      {
        user_id: userId,
        metadata: {
          session_id: sessionId,
          timestamp: new Date().toISOString(),
        },
      }
    )
  }

  async summarizeConversation(
    userId: string,
    sessionId: string
  ): Promise<ConversationSummary> {
    // 获取 Mem0 提取的记忆
    const memories = await this.client.getAll({
      user_id: userId,
      metadata: { session_id: sessionId },
    })

    // 生成摘要
    const summary = await this.generateSummary(memories)

    return {
      sessionId,
      summary: summary.text,
      keyTopics: summary.topics,
      decisions: summary.decisions,
      timestamp: new Date(),
      messageCount: memories.length,
      tokenCount: summary.tokenCount,
    }
  }

  async searchEpisodes(
    userId: string,
    query: string,
    options?: SearchOptions
  ): Promise<EpisodeSearchResult[]> {
    const results = await this.client.search(query, {
      user_id: userId,
      limit: options?.limit ?? 10,
    })

    return results.map(r => ({
      id: r.id,
      content: r.memory,
      score: r.score,
      timestamp: new Date(r.metadata.timestamp),
      sessionId: r.metadata.session_id,
    }))
  }

  async getTimeline(
    userId: string,
    startDate: Date,
    endDate: Date
  ): Promise<TimelineEntry[]> {
    const memories = await this.client.getAll({
      user_id: userId,
    })

    return memories
      .filter(m => {
        const ts = new Date(m.metadata.timestamp)
        return ts >= startDate && ts <= endDate
      })
      .map(m => ({
        id: m.id,
        type: 'memory',
        content: m.memory,
        timestamp: new Date(m.metadata.timestamp),
        metadata: m.metadata,
      }))
      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime())
  }
}
```

### 4.3 Mem0 画像记忆提供者

```typescript
// src/memory/providers/mem0/profile.ts

export class Mem0ProfileMemoryProvider implements IProfileMemoryProvider {
  readonly name = 'mem0-profile'
  readonly version = '1.0.0'

  private client: MemoryClient

  async addFact(
    userId: string,
    fact: Omit<UserFact, 'id' | 'createdAt'>
  ): Promise<string> {
    // 使用 Mem0 的 agent memory 存储用户事实
    const result = await this.client.add([
      {
        role: 'user',
        content: `User fact: ${fact.key} = ${fact.value}`,
      }
    ], {
      agent_id: `profile-${userId}`,
      metadata: {
        type: 'fact',
        category: fact.category,
        key: fact.key,
        confidence: fact.confidence,
        source: fact.source,
      },
    })

    return result[0].id
  }

  async getFacts(userId: string, category?: string): Promise<UserFact[]> {
    const memories = await this.client.getAll({
      agent_id: `profile-${userId}`,
    })

    return memories
      .filter(m => m.metadata.type === 'fact')
      .filter(m => !category || m.metadata.category === category)
      .map(m => ({
        id: m.id,
        category: m.metadata.category,
        key: m.metadata.key,
        value: this.extractValue(m.memory),
        confidence: m.metadata.confidence,
        source: m.metadata.source,
        createdAt: new Date(m.created_at),
        updatedAt: new Date(m.updated_at),
      }))
  }

  async extractFromConversation(
    userId: string,
    messages: Message[]
  ): Promise<ExtractedProfile> {
    // Mem0 自动从对话中提取用户信息
    const result = await this.client.add(
      messages.map(m => ({
        role: m.role,
        content: m.content,
      })),
      {
        agent_id: `profile-${userId}`,
        metadata: { type: 'conversation_extract' },
      }
    )

    // 返回提取的新事实
    return {
      newFacts: result.filter(r => r.event === 'ADD').map(r => ({
        id: r.id,
        content: r.memory,
      })),
      updatedFacts: result.filter(r => r.event === 'UPDATE').map(r => ({
        id: r.id,
        content: r.memory,
      })),
    }
  }
}
```

---

## 5. Graphiti 知识图谱集成

### 5.1 Graphiti 知识记忆提供者

```typescript
// src/memory/providers/graphiti/knowledge.ts

import { Graphiti } from 'graphiti-core'
import { MilvusClient } from '@zilliz/milvus2-sdk-node'

export class GraphitiKnowledgeProvider implements IKnowledgeMemoryProvider {
  readonly name = 'graphiti-knowledge'
  readonly version = '1.0.0'

  private graphiti: Graphiti
  private milvus: MilvusClient
  private minio: MinioClient

  constructor(private config: GraphitiConfig) {}

  async initialize(): Promise<void> {
    // 初始化 Graphiti (时态知识图谱)
    this.graphiti = new Graphiti({
      neo4jUri: this.config.neo4jUri,
      neo4jUser: this.config.neo4jUser,
      neo4jPassword: this.config.neo4jPassword,
      llmClient: this.config.llmClient,
    })

    // 初始化 Milvus (向量存储)
    this.milvus = new MilvusClient({
      address: this.config.milvusAddress,
    })

    // 确保集合存在
    await this.ensureCollections()
  }

  async addDocument(userId: string, document: DocumentInput): Promise<string> {
    const documentId = uuidv7()

    // 1. 解析文档内容
    const content = await this.parseDocument(document)

    // 2. 分块
    const chunks = this.chunkContent(content, {
      chunkSize: 512,
      overlap: 50,
    })

    // 3. 生成嵌入
    const embeddings = await this.generateEmbeddings(chunks)

    // 4. 存储到 Milvus
    await this.milvus.insert({
      collection_name: `knowledge_${userId}`,
      data: chunks.map((chunk, i) => ({
        id: `${documentId}_${i}`,
        document_id: documentId,
        content: chunk.text,
        embedding: embeddings[i],
        metadata: chunk.metadata,
      })),
    })

    // 5. 提取实体和关系到图谱
    await this.extractToGraph(userId, documentId, chunks)

    return documentId
  }

  async searchHybrid(
    userId: string,
    query: string,
    options?: HybridSearchOptions
  ): Promise<SearchResult[]> {
    // 1. 向量搜索
    const queryEmbedding = await this.generateEmbedding(query)
    const vectorResults = await this.milvus.search({
      collection_name: `knowledge_${userId}`,
      vector: queryEmbedding,
      limit: options?.limit ?? 10,
    })

    // 2. 图谱搜索
    const graphResults = await this.graphiti.search(query, {
      userId,
      limit: options?.limit ?? 10,
    })

    // 3. 融合结果
    return this.fuseResults(vectorResults, graphResults, options?.weights)
  }

  async queryGraph(userId: string, query: GraphQuery): Promise<GraphQueryResult> {
    // 使用 Graphiti 进行图查询
    const result = await this.graphiti.query(query.cypher, {
      userId,
      parameters: query.parameters,
    })

    return {
      nodes: result.nodes.map(this.formatNode),
      edges: result.edges.map(this.formatEdge),
      paths: result.paths,
    }
  }

  async getEntityContext(
    userId: string,
    entityId: string,
    depth: number = 2
  ): Promise<EntityContext> {
    // 获取实体及其关联上下文
    const result = await this.graphiti.getContext(entityId, {
      userId,
      depth,
      includeTimeline: true,
    })

    return {
      entity: result.entity,
      neighbors: result.neighbors,
      relationships: result.relationships,
      timeline: result.timeline,
    }
  }

  async answerWithGraph(userId: string, question: string): Promise<GraphAnswer> {
    // GraphRAG 风格的回答
    // 1. 提取问题中的实体
    const entities = await this.extractEntities(question)

    // 2. 在图谱中查找相关节点
    const context = await this.getRelevantContext(userId, entities)

    // 3. 结合向量搜索结果
    const vectorContext = await this.searchHybrid(userId, question, { limit: 5 })

    // 4. 生成回答
    const answer = await this.generateAnswer(question, {
      graphContext: context,
      vectorContext,
    })

    return {
      answer: answer.text,
      sources: answer.sources,
      entities: answer.mentionedEntities,
      confidence: answer.confidence,
    }
  }

  private async extractToGraph(
    userId: string,
    documentId: string,
    chunks: DocumentChunk[]
  ): Promise<void> {
    for (const chunk of chunks) {
      // 使用 Graphiti 添加到图谱
      await this.graphiti.addEpisode(
        chunk.text,
        {
          userId,
          documentId,
          source: 'document',
          timestamp: new Date(),
        }
      )
    }
  }
}
```

---

## 6. MinIO 对象存储集成

### 6.1 MinIO 存储提供者

```typescript
// src/memory/providers/minio/storage.ts

import { Client as MinioClient } from 'minio'
import { Readable } from 'stream'

export class MinIOStorageProvider implements IObjectStorageProvider {
  readonly name = 'minio'
  readonly version = '1.0.0'

  private client: MinioClient

  constructor(private config: MinIOConfig) {}

  async initialize(): Promise<void> {
    this.client = new MinioClient({
      endPoint: this.config.endpoint,
      port: this.config.port,
      useSSL: this.config.useSSL,
      accessKey: this.config.accessKey,
      secretKey: this.config.secretKey,
    })

    // 确保必要的 bucket 存在
    await this.ensureBuckets([
      'documents',      // 知识文档
      'media',          // 多媒体文件
      'embeddings',     // 向量索引快照
      'exports',        // 导出文件
    ])
  }

  async upload(
    bucket: string,
    key: string,
    data: Buffer | Readable,
    options?: UploadOptions
  ): Promise<string> {
    const metadata = {
      'Content-Type': options?.contentType || 'application/octet-stream',
      ...options?.metadata,
    }

    if (Buffer.isBuffer(data)) {
      await this.client.putObject(bucket, key, data, data.length, metadata)
    } else {
      await this.client.putObject(bucket, key, data, undefined, metadata)
    }

    return `${bucket}/${key}`
  }

  async download(bucket: string, key: string): Promise<Buffer> {
    const stream = await this.client.getObject(bucket, key)
    const chunks: Buffer[] = []

    return new Promise((resolve, reject) => {
      stream.on('data', chunk => chunks.push(chunk))
      stream.on('end', () => resolve(Buffer.concat(chunks)))
      stream.on('error', reject)
    })
  }

  async getStream(bucket: string, key: string): Promise<Readable> {
    return this.client.getObject(bucket, key)
  }

  async getSignedUrl(
    bucket: string,
    key: string,
    expiresIn: number = 3600
  ): Promise<string> {
    return this.client.presignedGetObject(bucket, key, expiresIn)
  }

  async delete(bucket: string, key: string): Promise<void> {
    await this.client.removeObject(bucket, key)
  }

  async exists(bucket: string, key: string): Promise<boolean> {
    try {
      await this.client.statObject(bucket, key)
      return true
    } catch (error) {
      if (error.code === 'NotFound') return false
      throw error
    }
  }

  async getMetadata(bucket: string, key: string): Promise<ObjectMetadata> {
    const stat = await this.client.statObject(bucket, key)
    return {
      size: stat.size,
      lastModified: stat.lastModified,
      etag: stat.etag,
      contentType: stat.metaData['content-type'],
      metadata: stat.metaData,
    }
  }

  async list(bucket: string, prefix?: string): Promise<ObjectInfo[]> {
    const objects: ObjectInfo[] = []
    const stream = this.client.listObjects(bucket, prefix, true)

    return new Promise((resolve, reject) => {
      stream.on('data', obj => {
        objects.push({
          key: obj.name,
          size: obj.size,
          lastModified: obj.lastModified,
          etag: obj.etag,
        })
      })
      stream.on('end', () => resolve(objects))
      stream.on('error', reject)
    })
  }

  private async ensureBuckets(buckets: string[]): Promise<void> {
    for (const bucket of buckets) {
      const exists = await this.client.bucketExists(bucket)
      if (!exists) {
        await this.client.makeBucket(bucket)
      }
    }
  }
}
```

### 6.2 多媒体文件处理

```typescript
// src/memory/media/processor.ts

import { IObjectStorageProvider } from '../interfaces'
import sharp from 'sharp'
import ffmpeg from 'fluent-ffmpeg'

export class MediaProcessor {
  constructor(
    private storage: IObjectStorageProvider,
    private config: MediaProcessorConfig
  ) {}

  /**
   * 处理上传的媒体文件
   */
  async processMedia(
    userId: string,
    file: Buffer,
    metadata: MediaMetadata
  ): Promise<ProcessedMedia> {
    const mediaId = uuidv7()
    const kind = this.detectMediaKind(metadata.mimeType)

    // 根据类型处理
    switch (kind) {
      case 'image':
        return this.processImage(userId, mediaId, file, metadata)
      case 'audio':
        return this.processAudio(userId, mediaId, file, metadata)
      case 'video':
        return this.processVideo(userId, mediaId, file, metadata)
      case 'document':
        return this.processDocument(userId, mediaId, file, metadata)
      default:
        return this.processGeneric(userId, mediaId, file, metadata)
    }
  }

  /**
   * 处理图片
   */
  private async processImage(
    userId: string,
    mediaId: string,
    file: Buffer,
    metadata: MediaMetadata
  ): Promise<ProcessedMedia> {
    const basePath = `media/${userId}/images/${mediaId}`

    // 1. 保存原图
    const originalKey = `${basePath}/original${this.getExtension(metadata.mimeType)}`
    await this.storage.upload('media', originalKey, file, {
      contentType: metadata.mimeType,
      metadata: { originalName: metadata.filename },
    })

    // 2. 生成缩略图
    const thumbnail = await sharp(file)
      .resize(256, 256, { fit: 'inside' })
      .jpeg({ quality: 80 })
      .toBuffer()

    const thumbnailKey = `${basePath}/thumbnail.jpg`
    await this.storage.upload('media', thumbnailKey, thumbnail, {
      contentType: 'image/jpeg',
    })

    // 3. 生成中等尺寸
    const medium = await sharp(file)
      .resize(1024, 1024, { fit: 'inside' })
      .jpeg({ quality: 85 })
      .toBuffer()

    const mediumKey = `${basePath}/medium.jpg`
    await this.storage.upload('media', mediumKey, medium, {
      contentType: 'image/jpeg',
    })

    // 4. 提取元数据
    const imageMetadata = await sharp(file).metadata()

    return {
      id: mediaId,
      kind: 'image',
      originalKey,
      variants: {
        thumbnail: thumbnailKey,
        medium: mediumKey,
      },
      metadata: {
        width: imageMetadata.width,
        height: imageMetadata.height,
        format: imageMetadata.format,
        size: file.length,
      },
    }
  }

  /**
   * 处理视频
   */
  private async processVideo(
    userId: string,
    mediaId: string,
    file: Buffer,
    metadata: MediaMetadata
  ): Promise<ProcessedMedia> {
    const basePath = `media/${userId}/videos/${mediaId}`

    // 1. 保存原视频
    const originalKey = `${basePath}/original${this.getExtension(metadata.mimeType)}`
    await this.storage.upload('media', originalKey, file, {
      contentType: metadata.mimeType,
    })

    // 2. 生成缩略图 (使用 ffmpeg)
    const thumbnailBuffer = await this.extractVideoThumbnail(file)
    const thumbnailKey = `${basePath}/thumbnail.jpg`
    await this.storage.upload('media', thumbnailKey, thumbnailBuffer, {
      contentType: 'image/jpeg',
    })

    // 3. 提取元数据
    const videoMetadata = await this.getVideoMetadata(file)

    return {
      id: mediaId,
      kind: 'video',
      originalKey,
      variants: {
        thumbnail: thumbnailKey,
      },
      metadata: {
        duration: videoMetadata.duration,
        width: videoMetadata.width,
        height: videoMetadata.height,
        codec: videoMetadata.codec,
        size: file.length,
      },
    }
  }

  /**
   * 处理文档
   */
  private async processDocument(
    userId: string,
    mediaId: string,
    file: Buffer,
    metadata: MediaMetadata
  ): Promise<ProcessedMedia> {
    const basePath = `documents/${userId}/${mediaId}`

    // 1. 保存原文档
    const originalKey = `${basePath}/original${this.getExtension(metadata.mimeType)}`
    await this.storage.upload('documents', originalKey, file, {
      contentType: metadata.mimeType,
      metadata: { originalName: metadata.filename },
    })

    // 2. 提取文本内容
    const textContent = await this.extractDocumentText(file, metadata.mimeType)
    const textKey = `${basePath}/content.txt`
    await this.storage.upload('documents', textKey, Buffer.from(textContent), {
      contentType: 'text/plain',
    })

    // 3. 生成预览图 (PDF 首页等)
    let previewKey: string | undefined
    if (metadata.mimeType === 'application/pdf') {
      const preview = await this.generatePdfPreview(file)
      previewKey = `${basePath}/preview.jpg`
      await this.storage.upload('documents', previewKey, preview, {
        contentType: 'image/jpeg',
      })
    }

    return {
      id: mediaId,
      kind: 'document',
      originalKey,
      variants: {
        text: textKey,
        preview: previewKey,
      },
      metadata: {
        pageCount: await this.getPageCount(file, metadata.mimeType),
        wordCount: textContent.split(/\s+/).length,
        size: file.length,
      },
      extractedText: textContent,
    }
  }

  /**
   * 提取文档文本
   */
  private async extractDocumentText(file: Buffer, mimeType: string): Promise<string> {
    switch (mimeType) {
      case 'application/pdf':
        return this.extractPdfText(file)
      case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
        return this.extractDocxText(file)
      case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
        return this.extractXlsxText(file)
      case 'text/plain':
        return file.toString('utf-8')
      default:
        throw new Error(`Unsupported document type: ${mimeType}`)
    }
  }
}
```

---

## 7. 配置文件

```yaml
# ~/.openclaw/config.yaml

memory:
  # 工作记忆配置
  working:
    provider: mem0
    options:
      apiKey: ${MEM0_API_KEY}
      # 或自托管
      baseUrl: http://localhost:8080
      sessionTtl: 1800  # 30 分钟

  # 情节记忆配置
  episodic:
    provider: mem0
    options:
      apiKey: ${MEM0_API_KEY}
      autoSummarize: true
      summaryModel: gpt-4o-mini

  # 画像记忆配置
  profile:
    provider: mem0
    options:
      apiKey: ${MEM0_API_KEY}
      extractionModel: gpt-4o-mini

  # 知识记忆配置
  knowledge:
    provider: graphiti
    options:
      # Neo4j 图数据库
      neo4jUri: bolt://localhost:7687
      neo4jUser: neo4j
      neo4jPassword: ${NEO4J_PASSWORD}

      # Milvus 向量存储
      milvusAddress: localhost:19530

      # Embedding 模型
      embeddingModel: text-embedding-3-small
      embeddingDimension: 1536

  # 对象存储配置
  storage:
    provider: minio
    options:
      endpoint: localhost
      port: 9000
      useSSL: false
      accessKey: ${MINIO_ACCESS_KEY}
      secretKey: ${MINIO_SECRET_KEY}

      # Bucket 配置
      buckets:
        documents: openclaw-documents
        media: openclaw-media
        embeddings: openclaw-embeddings
        exports: openclaw-exports

# 多媒体处理配置
media:
  # 大小限制
  limits:
    image: 10485760      # 10MB
    audio: 52428800      # 50MB
    video: 104857600     # 100MB
    document: 52428800   # 50MB

  # 图片处理
  image:
    thumbnailSize: 256
    mediumSize: 1024
    quality: 85

  # 视频处理
  video:
    thumbnailTime: 1     # 秒
    previewDuration: 10  # 预览视频长度
```

---

## 8. 项目结构

```
src/
├── memory/                              # 记忆系统
│   ├── interfaces/                      # 接口定义
│   │   ├── memory-provider.ts           # 基础接口
│   │   ├── working-memory.ts
│   │   ├── episodic-memory.ts
│   │   ├── profile-memory.ts
│   │   ├── knowledge-memory.ts
│   │   └── object-storage.ts
│   │
│   ├── providers/                       # 实现提供者
│   │   ├── factory.ts                   # 工厂类
│   │   ├── mem0/                        # Mem0 实现
│   │   │   ├── working.ts
│   │   │   ├── episodic.ts
│   │   │   └── profile.ts
│   │   ├── graphiti/                    # Graphiti 实现
│   │   │   └── knowledge.ts
│   │   ├── minio/                       # MinIO 实现
│   │   │   └── storage.ts
│   │   └── postgres/                    # PostgreSQL 备选
│   │       └── profile.ts
│   │
│   ├── media/                           # 多媒体处理
│   │   ├── processor.ts
│   │   ├── document-parser.ts
│   │   └── thumbnail-generator.ts
│   │
│   ├── manager.ts                       # 统一管理器
│   └── types.ts                         # 类型定义
│
└── gateway/
    └── server-methods/
        ├── memory.ts                    # 记忆 RPC 方法
        └── media.ts                     # 多媒体 RPC 方法
```

---

## 9. API 接口

### 9.1 记忆 API

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | memory.getContext | 获取用户记忆上下文 |
| POST | memory.addFact | 添加用户事实 |
| GET | memory.getFacts | 获取用户事实列表 |
| POST | memory.search | 跨层搜索记忆 |
| GET | memory.timeline | 获取时间线 |

### 9.2 知识 API

| 方法 | 路径 | 说明 |
|------|------|------|
| POST | knowledge.addDocument | 上传知识文档 |
| GET | knowledge.listDocuments | 获取文档列表 |
| DELETE | knowledge.deleteDocument | 删除文档 |
| POST | knowledge.search | 搜索知识库 |
| POST | knowledge.queryGraph | 图谱查询 |
| POST | knowledge.answer | 基于知识回答 |

### 9.3 多媒体 API

| 方法 | 路径 | 说明 |
|------|------|------|
| POST | media.upload | 上传媒体文件 |
| GET | media.download | 下载媒体文件 |
| GET | media.getUrl | 获取预签名 URL |
| DELETE | media.delete | 删除媒体文件 |

---

## 10. 实施计划

| 阶段 | 时间 | 任务 |
|------|------|------|
| **Phase 1** | Week 1-2 | 接口定义 + MinIO 集成 |
| **Phase 2** | Week 3-4 | Mem0 集成 (工作/情节/画像记忆) |
| **Phase 3** | Week 5-6 | Graphiti 集成 (知识图谱) |
| **Phase 4** | Week 7 | 多媒体处理器 |
| **Phase 5** | Week 8 | 测试 + 文档 |

---

*— 文档结束 —*
