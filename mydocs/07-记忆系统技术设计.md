# AI 个人助理平台 - 记忆系统技术设计文档

> 版本: 1.0 | 创建日期: 2026-02-07 | 状态: 设计中
>
> 本文档基于需求文档设计可插拔记忆系统的技术实现方案

---

## 1. 概述

### 1.1 设计目标

| 目标 | 说明 | 优先级 |
|------|------|--------|
| **可插拔架构** | 统一接口，支持多种后端实现 | P0 |
| **四层记忆** | 工作、情节、画像、知识记忆 | P0 |
| **MinIO 集成** | 多媒体文件使用对象存储 | P0 |
| **独立部署** | 可作为独立服务部署 | P1 |
| **渐进迁移** | 支持从现有系统平滑迁移 | P1 |

### 1.2 技术栈选型

| 组件 | 技术选型 | 说明 |
|------|----------|------|
| **核心语言** | TypeScript 5.x | 类型安全，与 OpenClaw 一致 |
| **运行时** | Node.js 22+ / Bun | 兼容两种运行时 |
| **工作记忆** | Mem0 + Redis | 短期会话 + 跨设备同步 |
| **情节记忆** | Mem0 | 自动摘要和事件提取 |
| **画像记忆** | PostgreSQL + Drizzle | 结构化存储 |
| **知识向量** | Milvus | 高性能向量搜索 |
| **知识图谱** | Neo4j + Graphiti | 时态知识图谱 |
| **对象存储** | MinIO | S3 兼容对象存储 |
| **消息队列** | Redis Streams | 异步任务处理 |
| **API 层** | JSON-RPC / gRPC | 与 Gateway 保持一致 |

### 1.3 与现有系统对比

| 功能 | 现有实现 | 新设计 | 迁移策略 |
|------|----------|--------|----------|
| 会话存储 | JSON5 文件 | Redis + Mem0 | 启动时导入 |
| 对话记录 | JSONL 文件 | PostgreSQL + Mem0 | 后台迁移 |
| 记忆索引 | SQLite + sqlite-vec | Milvus | 重建索引 |
| 嵌入模型 | OpenAI/Gemini/local | 统一接口 | 直接复用 |
| 媒体存储 | 文件系统 (2min TTL) | MinIO | 无缝切换 |

---

## 2. 系统架构

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Memory System Architecture                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐ │
│  │                          Client Layer (客户端层)                          │ │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌─────────────┐  │ │
│  │  │   OpenClaw   │  │   Windows    │  │   Other      │  │   Memory    │  │ │
│  │  │   Gateway    │  │   Client     │  │   Systems    │  │   CLI       │  │ │
│  │  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  └──────┬──────┘  │ │
│  │         │                 │                 │                  │         │ │
│  │         └─────────────────┼─────────────────┼──────────────────┘         │ │
│  │                           │                 │                            │ │
│  └───────────────────────────┼─────────────────┼────────────────────────────┘ │
│                              │                 │                              │
│  ┌───────────────────────────┼─────────────────┼────────────────────────────┐ │
│  │                           ▼                 ▼                            │ │
│  │                    ┌──────────────────────────────┐                      │ │
│  │                    │      Memory API Gateway      │                      │ │
│  │                    │    (JSON-RPC / gRPC / REST)  │                      │ │
│  │                    └──────────────┬───────────────┘                      │ │
│  │                                   │                                      │ │
│  │                    ┌──────────────┴───────────────┐                      │ │
│  │                    │      Memory Manager          │                      │ │
│  │                    │  (统一记忆管理器)             │                      │ │
│  │                    └──────────────┬───────────────┘                      │ │
│  │                                   │                                      │ │
│  │          ┌────────────────────────┼────────────────────────┐             │ │
│  │          │                        │                        │             │ │
│  │          ▼                        ▼                        ▼             │ │
│  │  ┌───────────────┐  ┌───────────────────────┐  ┌───────────────────┐    │ │
│  │  │ Working Mem   │  │   Persistent Memory   │  │  Object Storage   │    │ │
│  │  │  (工作记忆)    │  │     (持久记忆)         │  │   (对象存储)       │    │ │
│  │  ├───────────────┤  ├───────────────────────┤  ├───────────────────┤    │ │
│  │  │ • Mem0        │  │ • Episodic (情节)     │  │ • Documents       │    │ │
│  │  │ • Redis       │  │ • Profile (画像)      │  │ • Media           │    │ │
│  │  │ • In-Memory   │  │ • Knowledge (知识)    │  │ • Exports         │    │ │
│  │  └───────────────┘  └───────────────────────┘  └───────────────────┘    │ │
│  │          │                        │                        │             │ │
│  │          │                        ▼                        │             │ │
│  │          │          ┌───────────────────────┐              │             │ │
│  │          │          │   Provider Factory    │              │             │ │
│  │          │          │     (提供者工厂)       │              │             │ │
│  │          │          └───────────────────────┘              │             │ │
│  │          │                        │                        │             │ │
│  └──────────┼────────────────────────┼────────────────────────┼─────────────┘ │
│             │                        │                        │               │
│  ┌──────────┼────────────────────────┼────────────────────────┼─────────────┐ │
│  │          ▼                        ▼                        ▼             │ │
│  │  ┌───────────────┐  ┌───────────────────────┐  ┌───────────────────┐    │ │
│  │  │    Redis      │  │ Mem0 / PostgreSQL /   │  │      MinIO        │    │ │
│  │  │               │  │ Milvus / Neo4j        │  │   (S3 兼容)        │    │ │
│  │  └───────────────┘  └───────────────────────┘  └───────────────────┘    │ │
│  │                           Storage Layer (存储层)                          │ │
│  └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                               │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 模块划分

```
src/memory/
├── interfaces/                    # 接口定义
│   ├── index.ts                   # 导出所有接口
│   ├── memory-provider.ts         # 基础提供者接口
│   ├── working-memory.ts          # 工作记忆接口
│   ├── episodic-memory.ts         # 情节记忆接口
│   ├── profile-memory.ts          # 画像记忆接口
│   ├── knowledge-memory.ts        # 知识记忆接口
│   └── object-storage.ts          # 对象存储接口
│
├── providers/                     # 提供者实现
│   ├── factory.ts                 # 提供者工厂
│   ├── registry.ts                # 提供者注册表
│   │
│   ├── working/                   # 工作记忆实现
│   │   ├── mem0.ts                # Mem0 实现
│   │   ├── redis.ts               # Redis 实现
│   │   └── memory.ts              # 内存实现 (开发用)
│   │
│   ├── episodic/                  # 情节记忆实现
│   │   ├── mem0.ts                # Mem0 实现
│   │   └── postgres.ts            # PostgreSQL 实现
│   │
│   ├── profile/                   # 画像记忆实现
│   │   ├── mem0.ts                # Mem0 实现
│   │   └── postgres.ts            # PostgreSQL 实现
│   │
│   ├── knowledge/                 # 知识记忆实现
│   │   ├── graphiti.ts            # Graphiti + Milvus
│   │   ├── simple.ts              # SQLite + sqlite-vec (轻量)
│   │   └── hybrid.ts              # 混合实现
│   │
│   └── storage/                   # 对象存储实现
│       ├── minio.ts               # MinIO 实现
│       ├── s3.ts                  # AWS S3 实现
│       └── local.ts               # 本地文件系统 (开发用)
│
├── services/                      # 核心服务
│   ├── manager.ts                 # 统一记忆管理器
│   ├── context.ts                 # 记忆上下文构建
│   ├── extraction.ts              # 信息提取服务
│   ├── indexing.ts                # 索引服务
│   └── migration.ts               # 迁移服务
│
├── media/                         # 多媒体处理
│   ├── processor.ts               # 媒体处理器
│   ├── document-parser.ts         # 文档解析
│   ├── image-processor.ts         # 图片处理
│   ├── audio-processor.ts         # 音频处理
│   └── video-processor.ts         # 视频处理
│
├── embeddings/                    # 嵌入服务
│   ├── provider.ts                # 嵌入提供者接口
│   ├── openai.ts                  # OpenAI 实现
│   ├── gemini.ts                  # Gemini 实现
│   └── local.ts                   # 本地模型实现
│
├── api/                           # API 层
│   ├── rpc-methods.ts             # JSON-RPC 方法
│   ├── grpc-server.ts             # gRPC 服务
│   └── rest-router.ts             # REST 路由 (可选)
│
├── types/                         # 类型定义
│   ├── index.ts
│   ├── working.ts
│   ├── episodic.ts
│   ├── profile.ts
│   ├── knowledge.ts
│   └── media.ts
│
├── config/                        # 配置
│   ├── schema.ts                  # 配置模式
│   ├── defaults.ts                # 默认配置
│   └── loader.ts                  # 配置加载器
│
└── index.ts                       # 入口导出
```

---

## 3. 接口设计

### 3.1 基础接口

```typescript
// src/memory/interfaces/memory-provider.ts

/**
 * 健康状态
 */
export interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy'
  latency: number           // 毫秒
  message?: string
  details?: Record<string, unknown>
}

/**
 * 记忆提供者基础接口
 * 所有记忆实现必须实现此接口
 */
export interface IMemoryProvider {
  /** 提供者名称 */
  readonly name: string

  /** 提供者版本 */
  readonly version: string

  /**
   * 初始化提供者
   * 建立连接、创建必要的表/索引等
   */
  initialize(): Promise<void>

  /**
   * 关闭提供者
   * 释放连接、清理资源
   */
  shutdown(): Promise<void>

  /**
   * 健康检查
   */
  healthCheck(): Promise<HealthStatus>
}

/**
 * 提供者配置
 */
export interface ProviderConfig {
  provider: string           // 提供者名称
  options: Record<string, unknown>  // 提供者特定配置
}
```

### 3.2 工作记忆接口

```typescript
// src/memory/interfaces/working-memory.ts

import type { IMemoryProvider, HealthStatus } from './memory-provider'

/**
 * 会话选项
 */
export interface SessionOptions {
  contextWindow?: number     // 上下文窗口大小 (tokens)
  ttl?: number               // 超时时间 (毫秒)
  metadata?: Record<string, unknown>
}

/**
 * 消息角色
 */
export type MessageRole = 'user' | 'assistant' | 'system' | 'tool'

/**
 * 工具调用
 */
export interface ToolCall {
  id: string
  name: string
  arguments: Record<string, unknown>
}

/**
 * 工具结果
 */
export interface ToolResult {
  callId: string
  output: unknown
  error?: string
}

/**
 * 消息
 */
export interface Message {
  id: string
  role: MessageRole
  content: string
  toolCalls?: ToolCall[]
  toolResult?: ToolResult
  metadata?: Record<string, unknown>
  createdAt: Date
}

/**
 * 工具状态
 */
export interface ToolState {
  callId: string
  name: string
  status: 'pending' | 'running' | 'completed' | 'failed'
  startedAt: Date
  completedAt?: Date
  result?: unknown
  error?: string
}

/**
 * 待确认操作
 */
export interface PendingConfirm {
  id: string
  operation: string          // 操作描述
  type: 'destructive' | 'sensitive' | 'cost'
  details: Record<string, unknown>
  expiresAt: Date
  createdAt: Date
}

/**
 * 工作记忆
 */
export interface WorkingMemory {
  sessionId: string
  userId: string
  messages: Message[]
  contextWindow: number
  activeTools: ToolState[]
  pendingConfirms: PendingConfirm[]
  variables: Record<string, unknown>
  createdAt: Date
  lastActiveAt: Date
  ttl: number
}

/**
 * 会话信息
 */
export interface SessionInfo {
  sessionId: string
  userId: string
  messageCount: number
  createdAt: Date
  lastActiveAt: Date
  ttl: number
}

/**
 * 工作记忆提供者接口
 */
export interface IWorkingMemoryProvider extends IMemoryProvider {
  // 会话管理
  createSession(userId: string, options?: SessionOptions): Promise<string>
  getSession(sessionId: string): Promise<WorkingMemory | null>
  updateSession(sessionId: string, updates: Partial<WorkingMemory>): Promise<void>
  deleteSession(sessionId: string): Promise<void>
  listSessions(userId: string): Promise<SessionInfo[]>

  // 消息管理
  addMessage(sessionId: string, message: Omit<Message, 'id' | 'createdAt'>): Promise<string>
  getMessages(sessionId: string, limit?: number): Promise<Message[]>
  getContextWindow(sessionId: string, maxTokens: number): Promise<Message[]>

  // 状态管理
  setVariable(sessionId: string, key: string, value: unknown): Promise<void>
  getVariable(sessionId: string, key: string): Promise<unknown>
  clearVariables(sessionId: string): Promise<void>

  // 工具状态
  addToolState(sessionId: string, state: Omit<ToolState, 'startedAt'>): Promise<void>
  updateToolState(sessionId: string, callId: string, updates: Partial<ToolState>): Promise<void>
  getToolStates(sessionId: string): Promise<ToolState[]>

  // 待确认操作
  addPendingConfirm(sessionId: string, confirm: Omit<PendingConfirm, 'id' | 'createdAt'>): Promise<string>
  resolvePendingConfirm(sessionId: string, confirmId: string, confirmed: boolean): Promise<void>
  getPendingConfirms(sessionId: string): Promise<PendingConfirm[]>
}
```

### 3.3 情节记忆接口

```typescript
// src/memory/interfaces/episodic-memory.ts

import type { IMemoryProvider } from './memory-provider'
import type { Message } from './working-memory'

/**
 * 对话摘要
 */
export interface ConversationSummary {
  id: string
  sessionId: string
  summary: string
  keyTopics: string[]
  decisions: string[]
  messageCount: number
  tokenCount: number
  timestamp: Date
}

/**
 * 关键事件类型
 */
export type KeyEventType =
  | 'task_completed'
  | 'preference_changed'
  | 'important_info'
  | 'milestone'
  | 'decision'
  | 'error'
  | 'feedback'

/**
 * 关键事件
 */
export interface KeyEvent {
  id: string
  type: KeyEventType
  description: string
  context: string
  importance: number         // 0-1
  relatedSessions: string[]
  timestamp: Date
  metadata?: Record<string, unknown>
}

/**
 * 情绪记录
 */
export interface EmotionalRecord {
  sessionId: string
  sentiment: 'positive' | 'neutral' | 'negative'
  satisfaction: number       // 0-1
  frustration: number        // 0-1
  confidence: number         // 检测置信度
  timestamp: Date
}

/**
 * 情绪趋势
 */
export interface EmotionTrend {
  averageSentiment: number
  satisfactionTrend: number[]
  frustrationTrend: number[]
  timestamps: Date[]
}

/**
 * 查询选项
 */
export interface EpisodicQueryOptions {
  startDate?: Date
  endDate?: Date
  topics?: string[]
  limit?: number
  offset?: number
}

/**
 * 事件查询选项
 */
export interface EventQueryOptions {
  types?: KeyEventType[]
  startDate?: Date
  endDate?: Date
  minImportance?: number
  limit?: number
  offset?: number
}

/**
 * 搜索选项
 */
export interface EpisodicSearchOptions {
  limit?: number
  minScore?: number
  startDate?: Date
  endDate?: Date
}

/**
 * 情节搜索结果
 */
export interface EpisodeSearchResult {
  id: string
  content: string
  score: number
  type: 'conversation' | 'event' | 'memory'
  timestamp: Date
  sessionId?: string
  metadata?: Record<string, unknown>
}

/**
 * 时间线条目
 */
export interface TimelineEntry {
  id: string
  type: 'conversation' | 'event' | 'milestone'
  title: string
  description: string
  timestamp: Date
  importance: number
  metadata?: Record<string, unknown>
}

/**
 * 情节记忆提供者接口
 */
export interface IEpisodicMemoryProvider extends IMemoryProvider {
  // 对话历史
  addConversation(userId: string, sessionId: string, messages: Message[]): Promise<void>
  summarizeConversation(userId: string, sessionId: string): Promise<ConversationSummary>
  getConversationHistory(userId: string, options?: EpisodicQueryOptions): Promise<ConversationSummary[]>
  deleteConversation(userId: string, sessionId: string): Promise<void>

  // 关键事件
  addKeyEvent(userId: string, event: Omit<KeyEvent, 'id'>): Promise<string>
  getKeyEvents(userId: string, options?: EventQueryOptions): Promise<KeyEvent[]>
  updateKeyEvent(userId: string, eventId: string, updates: Partial<KeyEvent>): Promise<void>
  deleteKeyEvent(userId: string, eventId: string): Promise<void>

  // 搜索
  searchEpisodes(userId: string, query: string, options?: EpisodicSearchOptions): Promise<EpisodeSearchResult[]>
  getTimeline(userId: string, startDate: Date, endDate: Date): Promise<TimelineEntry[]>

  // 情绪追踪
  recordEmotion(userId: string, sessionId: string, emotion: Omit<EmotionalRecord, 'sessionId'>): Promise<void>
  getEmotionTrend(userId: string, startDate: Date, endDate: Date): Promise<EmotionTrend>
}
```

### 3.4 画像记忆接口

```typescript
// src/memory/interfaces/profile-memory.ts

import type { IMemoryProvider } from './memory-provider'
import type { Message } from './working-memory'

/**
 * 事实类别
 */
export type FactCategory =
  | 'personal'
  | 'work'
  | 'hobby'
  | 'skill'
  | 'relationship'
  | 'health'
  | 'finance'
  | 'other'

/**
 * 用户事实
 */
export interface UserFact {
  id: string
  category: FactCategory
  key: string
  value: string
  confidence: number         // 0-1
  source: 'explicit' | 'inferred'
  extractedFrom?: string     // 来源会话 ID
  sensitive: boolean
  createdAt: Date
  updatedAt: Date
  validUntil?: Date         // 有效期
}

/**
 * 用户偏好
 */
export interface UserPreferences {
  // 交互偏好
  language: string
  timezone: string
  responseStyle: 'concise' | 'detailed' | 'casual' | 'formal'
  confirmLevel: 'low' | 'medium' | 'high'

  // 功能偏好
  favoriteSkills: string[]
  disabledSkills: string[]

  // AI 行为偏好
  thinkingLevel: 'low' | 'medium' | 'high'
  verboseLevel: 'minimal' | 'normal' | 'verbose'

  // 通知偏好
  notifications: {
    enabled: boolean
    quietHours?: { start: string; end: string }
    channels: string[]
  }
}

/**
 * 行为模式
 */
export interface BehaviorPattern {
  id: string
  type: 'time_preference' | 'topic_interest' | 'work_style' | 'communication'
  pattern: string
  evidence: string[]
  confidence: number
  confirmed?: boolean        // 用户确认
  updatedAt: Date
}

/**
 * 提取的画像
 */
export interface ExtractedProfile {
  newFacts: Array<{
    id: string
    content: string
    category: FactCategory
    confidence: number
  }>
  updatedFacts: Array<{
    id: string
    content: string
    previousValue: string
  }>
  newPatterns: Array<{
    type: BehaviorPattern['type']
    pattern: string
    confidence: number
  }>
}

/**
 * 画像记忆提供者接口
 */
export interface IProfileMemoryProvider extends IMemoryProvider {
  // 事实管理
  addFact(userId: string, fact: Omit<UserFact, 'id' | 'createdAt' | 'updatedAt'>): Promise<string>
  updateFact(userId: string, factId: string, updates: Partial<UserFact>): Promise<void>
  deleteFact(userId: string, factId: string): Promise<void>
  getFacts(userId: string, category?: FactCategory): Promise<UserFact[]>
  searchFacts(userId: string, query: string): Promise<UserFact[]>

  // 偏好管理
  getPreferences(userId: string): Promise<UserPreferences>
  updatePreferences(userId: string, updates: Partial<UserPreferences>): Promise<void>
  resetPreferences(userId: string): Promise<void>

  // 行为模式
  addPattern(userId: string, pattern: Omit<BehaviorPattern, 'id' | 'updatedAt'>): Promise<string>
  getPatterns(userId: string): Promise<BehaviorPattern[]>
  updatePattern(userId: string, patternId: string, updates: Partial<BehaviorPattern>): Promise<void>
  deletePattern(userId: string, patternId: string): Promise<void>
  confirmPattern(userId: string, patternId: string, confirmed: boolean): Promise<void>

  // 自动提取
  extractFromConversation(userId: string, messages: Message[]): Promise<ExtractedProfile>
  confirmExtraction(userId: string, extractionId: string, confirmed: boolean): Promise<void>

  // 导出
  exportProfile(userId: string): Promise<{
    facts: UserFact[]
    preferences: UserPreferences
    patterns: BehaviorPattern[]
  }>
}
```

### 3.5 知识记忆接口

```typescript
// src/memory/interfaces/knowledge-memory.ts

import type { IMemoryProvider } from './memory-provider'
import type { Message } from './working-memory'
import type { Readable } from 'stream'

/**
 * 文档输入
 */
export interface DocumentInput {
  title: string
  content?: Buffer | Readable
  objectKey?: string         // 已上传的对象键
  mimeType: string
  source: 'upload' | 'conversation' | 'web' | 'integration'
  metadata?: Record<string, unknown>
}

/**
 * 文档状态
 */
export type DocumentStatus = 'pending' | 'processing' | 'indexed' | 'failed'

/**
 * 文档块
 */
export interface DocumentChunk {
  id: string
  documentId: string
  content: string
  embedding?: number[]
  startOffset: number
  endOffset: number
  metadata: {
    page?: number
    section?: string
    heading?: string
  }
}

/**
 * 知识文档
 */
export interface KnowledgeDocument {
  id: string
  title: string
  source: DocumentInput['source']
  objectKey: string
  mimeType: string
  size: number
  status: DocumentStatus
  chunkCount: number
  embeddingModel: string
  errorMessage?: string
  metadata: Record<string, unknown>
  createdAt: Date
  processedAt?: Date
}

/**
 * 实体
 */
export interface Entity {
  id: string
  name: string
  type: string               // person, organization, concept, location, event, etc.
  description?: string
  properties: Record<string, unknown>
  mentionCount: number
  createdAt: Date
  updatedAt: Date
}

/**
 * 关系
 */
export interface Relationship {
  id: string
  sourceId: string
  targetId: string
  type: string               // works_at, knows, part_of, related_to, etc.
  properties: Record<string, unknown>
  weight: number             // 关系强度 0-1
  validFrom?: Date
  validUntil?: Date
  createdAt: Date
}

/**
 * 社区 (GraphRAG)
 */
export interface Community {
  id: string
  level: number
  entityIds: string[]
  summary: string
  keyThemes: string[]
  parentCommunityId?: string
}

/**
 * 搜索结果
 */
export interface SearchResult {
  id: string
  content: string
  score: number
  documentId?: string
  documentTitle?: string
  metadata?: Record<string, unknown>
}

/**
 * 向量搜索选项
 */
export interface VectorSearchOptions {
  limit?: number
  minScore?: number
  filter?: Record<string, unknown>
}

/**
 * 混合搜索选项
 */
export interface HybridSearchOptions extends VectorSearchOptions {
  vectorWeight?: number      // 向量权重 (默认 0.7)
  textWeight?: number        // 文本权重 (默认 0.3)
  rerank?: boolean           // 是否重排序
}

/**
 * 图查询
 */
export interface GraphQuery {
  cypher?: string            // Cypher 查询语句
  pattern?: {                // 或模式匹配
    entityType?: string
    relationshipType?: string
    depth?: number
  }
  parameters?: Record<string, unknown>
}

/**
 * 图查询结果
 */
export interface GraphQueryResult {
  nodes: Entity[]
  edges: Relationship[]
  paths?: Array<{
    nodes: string[]
    relationships: string[]
  }>
}

/**
 * 实体上下文
 */
export interface EntityContext {
  entity: Entity
  neighbors: Entity[]
  relationships: Relationship[]
  relatedDocuments: Array<{
    id: string
    title: string
    relevance: number
  }>
}

/**
 * 图谱回答
 */
export interface GraphAnswer {
  answer: string
  sources: Array<{
    type: 'document' | 'entity' | 'relationship'
    id: string
    content: string
    relevance: number
  }>
  entities: Entity[]
  confidence: number
}

/**
 * 列表选项
 */
export interface ListOptions {
  status?: DocumentStatus
  source?: DocumentInput['source']
  limit?: number
  offset?: number
  orderBy?: 'createdAt' | 'processedAt' | 'title'
  order?: 'asc' | 'desc'
}

/**
 * 知识记忆提供者接口
 */
export interface IKnowledgeMemoryProvider extends IMemoryProvider {
  // 文档管理
  addDocument(userId: string, document: DocumentInput): Promise<string>
  getDocument(userId: string, documentId: string): Promise<KnowledgeDocument | null>
  deleteDocument(userId: string, documentId: string): Promise<void>
  listDocuments(userId: string, options?: ListOptions): Promise<KnowledgeDocument[]>
  getDocumentStatus(userId: string, documentId: string): Promise<{
    status: DocumentStatus
    progress?: number
    message?: string
  }>

  // 索引管理
  indexDocument(userId: string, documentId: string): Promise<void>
  reindexDocument(userId: string, documentId: string): Promise<void>
  reindexAll(userId: string): Promise<void>

  // 向量搜索
  searchSimilar(userId: string, query: string, options?: VectorSearchOptions): Promise<SearchResult[]>
  searchHybrid(userId: string, query: string, options?: HybridSearchOptions): Promise<SearchResult[]>

  // 知识图谱
  addEntity(userId: string, entity: Omit<Entity, 'id' | 'createdAt' | 'updatedAt' | 'mentionCount'>): Promise<string>
  getEntity(userId: string, entityId: string): Promise<Entity | null>
  updateEntity(userId: string, entityId: string, updates: Partial<Entity>): Promise<void>
  deleteEntity(userId: string, entityId: string): Promise<void>

  addRelationship(userId: string, relationship: Omit<Relationship, 'id' | 'createdAt'>): Promise<string>
  getRelationship(userId: string, relationshipId: string): Promise<Relationship | null>
  updateRelationship(userId: string, relationshipId: string, updates: Partial<Relationship>): Promise<void>
  deleteRelationship(userId: string, relationshipId: string): Promise<void>

  queryGraph(userId: string, query: GraphQuery): Promise<GraphQueryResult>
  getEntityContext(userId: string, entityId: string, depth?: number): Promise<EntityContext>

  // GraphRAG
  buildCommunities(userId: string): Promise<void>
  getCommunities(userId: string, level?: number): Promise<Community[]>
  answerWithGraph(userId: string, question: string): Promise<GraphAnswer>

  // 对话转知识
  importConversation(userId: string, sessionId: string, messages: Message[]): Promise<{
    documentId: string
    entities: string[]
    relationships: string[]
  }>
}
```

### 3.6 对象存储接口

```typescript
// src/memory/interfaces/object-storage.ts

import type { IMemoryProvider } from './memory-provider'
import type { Readable } from 'stream'

/**
 * 上传选项
 */
export interface UploadOptions {
  contentType?: string
  metadata?: Record<string, string>
  cacheControl?: string
}

/**
 * 分片上传选项
 */
export interface MultipartOptions extends UploadOptions {
  partSize?: number          // 分片大小 (默认 5MB)
  concurrency?: number       // 并发数 (默认 4)
}

/**
 * 列表选项
 */
export interface StorageListOptions {
  limit?: number
  continuationToken?: string
  delimiter?: string
}

/**
 * 对象元数据
 */
export interface ObjectMetadata {
  size: number
  lastModified: Date
  etag: string
  contentType: string
  metadata: Record<string, string>
}

/**
 * 对象信息
 */
export interface ObjectInfo {
  key: string
  size: number
  lastModified: Date
  etag: string
}

/**
 * 存储桶信息
 */
export interface BucketInfo {
  name: string
  createdAt: Date
}

/**
 * 存储用量
 */
export interface StorageUsage {
  totalSize: number
  objectCount: number
}

/**
 * 列表结果
 */
export interface ListResult {
  objects: ObjectInfo[]
  prefixes: string[]
  continuationToken?: string
  isTruncated: boolean
}

/**
 * 对象存储提供者接口
 */
export interface IObjectStorageProvider extends IMemoryProvider {
  // 上传下载
  upload(bucket: string, key: string, data: Buffer | Readable, options?: UploadOptions): Promise<string>
  uploadMultipart(bucket: string, key: string, stream: Readable, options?: MultipartOptions): Promise<string>
  download(bucket: string, key: string): Promise<Buffer>
  getStream(bucket: string, key: string): Promise<Readable>
  getSignedUrl(bucket: string, key: string, expiresIn?: number): Promise<string>
  getSignedUploadUrl(bucket: string, key: string, expiresIn?: number): Promise<string>

  // 文件管理
  delete(bucket: string, key: string): Promise<void>
  deleteMany(bucket: string, keys: string[]): Promise<void>
  copy(srcBucket: string, srcKey: string, dstBucket: string, dstKey: string): Promise<void>
  exists(bucket: string, key: string): Promise<boolean>
  getMetadata(bucket: string, key: string): Promise<ObjectMetadata>
  list(bucket: string, prefix?: string, options?: StorageListOptions): Promise<ListResult>

  // 存储桶管理
  createBucket(bucket: string): Promise<void>
  deleteBucket(bucket: string): Promise<void>
  bucketExists(bucket: string): Promise<boolean>
  listBuckets(): Promise<BucketInfo[]>

  // 统计
  getStorageUsage(bucket: string, prefix?: string): Promise<StorageUsage>
}
```

---

## 4. 提供者实现

### 4.1 提供者工厂

```typescript
// src/memory/providers/factory.ts

import type {
  IMemoryProvider,
  IWorkingMemoryProvider,
  IEpisodicMemoryProvider,
  IProfileMemoryProvider,
  IKnowledgeMemoryProvider,
  IObjectStorageProvider,
  ProviderConfig,
} from '../interfaces'

/**
 * 记忆类型
 */
export type MemoryType = 'working' | 'episodic' | 'profile' | 'knowledge' | 'storage'

/**
 * 提供者构造函数类型
 */
export type ProviderConstructor<T extends IMemoryProvider = IMemoryProvider> = new (
  options: Record<string, unknown>
) => T

/**
 * 提供者注册表
 */
const registry = new Map<string, ProviderConstructor>()

/**
 * 注册提供者
 *
 * @param type - 记忆类型
 * @param name - 提供者名称
 * @param constructor - 构造函数
 */
export function registerProvider<T extends IMemoryProvider>(
  type: MemoryType,
  name: string,
  constructor: ProviderConstructor<T>
): void {
  const key = `${type}:${name}`
  if (registry.has(key)) {
    console.warn(`[MemoryProviderFactory] 覆盖已存在的提供者: ${key}`)
  }
  registry.set(key, constructor as ProviderConstructor)
}

/**
 * 创建提供者实例
 *
 * @param type - 记忆类型
 * @param config - 提供者配置
 * @returns 提供者实例
 */
export function createProvider<T extends IMemoryProvider>(
  type: MemoryType,
  config: ProviderConfig
): T {
  const key = `${type}:${config.provider}`
  const Constructor = registry.get(key)

  if (!Constructor) {
    throw new Error(`[MemoryProviderFactory] 未知的记忆提供者: ${key}，可用: ${getAvailableProviders(type).join(', ')}`)
  }

  return new Constructor(config.options) as T
}

/**
 * 获取可用的提供者列表
 *
 * @param type - 记忆类型
 * @returns 提供者名称列表
 */
export function getAvailableProviders(type: MemoryType): string[] {
  const prefix = `${type}:`
  return Array.from(registry.keys())
    .filter(key => key.startsWith(prefix))
    .map(key => key.slice(prefix.length))
}

/**
 * 检查提供者是否已注册
 *
 * @param type - 记忆类型
 * @param name - 提供者名称
 * @returns 是否已注册
 */
export function hasProvider(type: MemoryType, name: string): boolean {
  return registry.has(`${type}:${name}`)
}

// 类型安全的创建函数
export function createWorkingMemoryProvider(config: ProviderConfig): IWorkingMemoryProvider {
  return createProvider<IWorkingMemoryProvider>('working', config)
}

export function createEpisodicMemoryProvider(config: ProviderConfig): IEpisodicMemoryProvider {
  return createProvider<IEpisodicMemoryProvider>('episodic', config)
}

export function createProfileMemoryProvider(config: ProviderConfig): IProfileMemoryProvider {
  return createProvider<IProfileMemoryProvider>('profile', config)
}

export function createKnowledgeMemoryProvider(config: ProviderConfig): IKnowledgeMemoryProvider {
  return createProvider<IKnowledgeMemoryProvider>('knowledge', config)
}

export function createObjectStorageProvider(config: ProviderConfig): IObjectStorageProvider {
  return createProvider<IObjectStorageProvider>('storage', config)
}
```

### 4.2 Mem0 工作记忆实现

```typescript
// src/memory/providers/working/mem0.ts

import { MemoryClient } from 'mem0ai'
import { createId } from '@paralleldrive/cuid2'
import type {
  IWorkingMemoryProvider,
  HealthStatus,
  SessionOptions,
  Message,
  WorkingMemory,
  SessionInfo,
  ToolState,
  PendingConfirm,
} from '../../interfaces'
import { registerProvider } from '../factory'

/**
 * Mem0 配置
 */
export interface Mem0Config {
  apiKey?: string            // Mem0 Cloud API Key
  baseUrl?: string           // 自托管地址
  sessionTtl?: number        // 会话 TTL (毫秒)
  syncToRemote?: boolean     // 是否同步到远程
}

/**
 * Mem0 工作记忆提供者
 *
 * 使用本地 Map 存储会话，可选同步到 Mem0 远程
 */
export class Mem0WorkingMemoryProvider implements IWorkingMemoryProvider {
  readonly name = 'mem0-working'
  readonly version = '1.0.0'

  private client: MemoryClient | null = null
  private sessions = new Map<string, WorkingMemory>()
  private cleanupInterval: NodeJS.Timeout | null = null

  constructor(private config: Mem0Config) {}

  /**
   * 初始化提供者
   */
  async initialize(): Promise<void> {
    console.log(`[${this.name}] 初始化 Mem0 工作记忆提供者...`)

    // 初始化 Mem0 客户端 (可选)
    if (this.config.apiKey || this.config.baseUrl) {
      this.client = new MemoryClient({
        apiKey: this.config.apiKey,
        host: this.config.baseUrl,
      })
    }

    // 启动过期清理定时器
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpiredSessions()
    }, 60_000) // 每分钟检查一次

    console.log(`[${this.name}] 初始化完成`)
  }

  /**
   * 关闭提供者
   */
  async shutdown(): Promise<void> {
    console.log(`[${this.name}] 关闭提供者...`)

    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval)
      this.cleanupInterval = null
    }

    this.sessions.clear()
    console.log(`[${this.name}] 已关闭`)
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<HealthStatus> {
    const start = Date.now()

    try {
      // 检查 Mem0 连接 (如果配置了)
      if (this.client) {
        await this.client.getAll({ limit: 1 })
      }

      return {
        status: 'healthy',
        latency: Date.now() - start,
        details: {
          sessionCount: this.sessions.size,
          hasRemote: !!this.client,
        },
      }
    } catch (error) {
      return {
        status: 'degraded',
        latency: Date.now() - start,
        message: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }

  /**
   * 创建会话
   */
  async createSession(userId: string, options?: SessionOptions): Promise<string> {
    const sessionId = createId()
    const now = new Date()

    const session: WorkingMemory = {
      sessionId,
      userId,
      messages: [],
      contextWindow: options?.contextWindow ?? 8000,
      activeTools: [],
      pendingConfirms: [],
      variables: {},
      createdAt: now,
      lastActiveAt: now,
      ttl: options?.ttl ?? this.config.sessionTtl ?? 30 * 60 * 1000,
    }

    this.sessions.set(sessionId, session)
    console.log(`[${this.name}] 创建会话: ${sessionId} (用户: ${userId})`)

    return sessionId
  }

  /**
   * 获取会话
   */
  async getSession(sessionId: string): Promise<WorkingMemory | null> {
    const session = this.sessions.get(sessionId)

    if (!session) {
      return null
    }

    // 检查是否过期
    if (this.isSessionExpired(session)) {
      await this.deleteSession(sessionId)
      return null
    }

    return session
  }

  /**
   * 更新会话
   */
  async updateSession(sessionId: string, updates: Partial<WorkingMemory>): Promise<void> {
    const session = await this.getSession(sessionId)
    if (!session) {
      throw new Error(`会话不存在: ${sessionId}`)
    }

    Object.assign(session, updates, { lastActiveAt: new Date() })
  }

  /**
   * 删除会话
   */
  async deleteSession(sessionId: string): Promise<void> {
    this.sessions.delete(sessionId)
    console.log(`[${this.name}] 删除会话: ${sessionId}`)
  }

  /**
   * 列出用户会话
   */
  async listSessions(userId: string): Promise<SessionInfo[]> {
    const result: SessionInfo[] = []

    for (const session of this.sessions.values()) {
      if (session.userId === userId && !this.isSessionExpired(session)) {
        result.push({
          sessionId: session.sessionId,
          userId: session.userId,
          messageCount: session.messages.length,
          createdAt: session.createdAt,
          lastActiveAt: session.lastActiveAt,
          ttl: session.ttl,
        })
      }
    }

    return result.sort((a, b) => b.lastActiveAt.getTime() - a.lastActiveAt.getTime())
  }

  /**
   * 添加消息
   */
  async addMessage(
    sessionId: string,
    message: Omit<Message, 'id' | 'createdAt'>
  ): Promise<string> {
    const session = await this.getSession(sessionId)
    if (!session) {
      throw new Error(`会话不存在: ${sessionId}`)
    }

    const messageId = createId()
    const fullMessage: Message = {
      ...message,
      id: messageId,
      createdAt: new Date(),
    }

    session.messages.push(fullMessage)
    session.lastActiveAt = new Date()

    // 同步到 Mem0 (如果配置了)
    if (this.client && this.config.syncToRemote) {
      try {
        await this.client.add([
          {
            role: message.role,
            content: message.content,
          }
        ], {
          user_id: session.userId,
          session_id: sessionId,
        })
      } catch (error) {
        console.error(`[${this.name}] 同步到 Mem0 失败:`, error)
      }
    }

    return messageId
  }

  /**
   * 获取消息
   */
  async getMessages(sessionId: string, limit?: number): Promise<Message[]> {
    const session = await this.getSession(sessionId)
    if (!session) {
      return []
    }

    const messages = session.messages
    if (limit && limit > 0) {
      return messages.slice(-limit)
    }

    return messages
  }

  /**
   * 获取上下文窗口
   */
  async getContextWindow(sessionId: string, maxTokens: number): Promise<Message[]> {
    const session = await this.getSession(sessionId)
    if (!session) {
      return []
    }

    const result: Message[] = []
    let tokenCount = 0

    // 从后往前取消息
    for (let i = session.messages.length - 1; i >= 0; i--) {
      const msg = session.messages[i]
      const msgTokens = this.estimateTokens(msg.content)

      if (tokenCount + msgTokens > maxTokens) {
        break
      }

      result.unshift(msg)
      tokenCount += msgTokens
    }

    return result
  }

  /**
   * 设置变量
   */
  async setVariable(sessionId: string, key: string, value: unknown): Promise<void> {
    const session = await this.getSession(sessionId)
    if (!session) {
      throw new Error(`会话不存在: ${sessionId}`)
    }

    session.variables[key] = value
    session.lastActiveAt = new Date()
  }

  /**
   * 获取变量
   */
  async getVariable(sessionId: string, key: string): Promise<unknown> {
    const session = await this.getSession(sessionId)
    return session?.variables[key]
  }

  /**
   * 清除变量
   */
  async clearVariables(sessionId: string): Promise<void> {
    const session = await this.getSession(sessionId)
    if (session) {
      session.variables = {}
      session.lastActiveAt = new Date()
    }
  }

  /**
   * 添加工具状态
   */
  async addToolState(sessionId: string, state: Omit<ToolState, 'startedAt'>): Promise<void> {
    const session = await this.getSession(sessionId)
    if (!session) {
      throw new Error(`会话不存在: ${sessionId}`)
    }

    session.activeTools.push({
      ...state,
      startedAt: new Date(),
    })
    session.lastActiveAt = new Date()
  }

  /**
   * 更新工具状态
   */
  async updateToolState(
    sessionId: string,
    callId: string,
    updates: Partial<ToolState>
  ): Promise<void> {
    const session = await this.getSession(sessionId)
    if (!session) {
      throw new Error(`会话不存在: ${sessionId}`)
    }

    const tool = session.activeTools.find(t => t.callId === callId)
    if (tool) {
      Object.assign(tool, updates)
    }
    session.lastActiveAt = new Date()
  }

  /**
   * 获取工具状态
   */
  async getToolStates(sessionId: string): Promise<ToolState[]> {
    const session = await this.getSession(sessionId)
    return session?.activeTools ?? []
  }

  /**
   * 添加待确认操作
   */
  async addPendingConfirm(
    sessionId: string,
    confirm: Omit<PendingConfirm, 'id' | 'createdAt'>
  ): Promise<string> {
    const session = await this.getSession(sessionId)
    if (!session) {
      throw new Error(`会话不存在: ${sessionId}`)
    }

    const confirmId = createId()
    session.pendingConfirms.push({
      ...confirm,
      id: confirmId,
      createdAt: new Date(),
    })
    session.lastActiveAt = new Date()

    return confirmId
  }

  /**
   * 解决待确认操作
   */
  async resolvePendingConfirm(
    sessionId: string,
    confirmId: string,
    confirmed: boolean
  ): Promise<void> {
    const session = await this.getSession(sessionId)
    if (!session) {
      throw new Error(`会话不存在: ${sessionId}`)
    }

    const index = session.pendingConfirms.findIndex(c => c.id === confirmId)
    if (index !== -1) {
      session.pendingConfirms.splice(index, 1)
    }
    session.lastActiveAt = new Date()
  }

  /**
   * 获取待确认操作
   */
  async getPendingConfirms(sessionId: string): Promise<PendingConfirm[]> {
    const session = await this.getSession(sessionId)
    if (!session) {
      return []
    }

    // 过滤已过期的
    const now = new Date()
    return session.pendingConfirms.filter(c => c.expiresAt > now)
  }

  // ==================== 私有方法 ====================

  /**
   * 检查会话是否过期
   */
  private isSessionExpired(session: WorkingMemory): boolean {
    const now = Date.now()
    const expiresAt = session.lastActiveAt.getTime() + session.ttl
    return now > expiresAt
  }

  /**
   * 清理过期会话
   */
  private cleanupExpiredSessions(): void {
    let cleaned = 0

    for (const [sessionId, session] of this.sessions.entries()) {
      if (this.isSessionExpired(session)) {
        this.sessions.delete(sessionId)
        cleaned++
      }
    }

    if (cleaned > 0) {
      console.log(`[${this.name}] 清理了 ${cleaned} 个过期会话`)
    }
  }

  /**
   * 估算 Token 数
   * 简单实现：每 4 个字符约 1 个 token
   */
  private estimateTokens(text: string): number {
    return Math.ceil(text.length / 4)
  }
}

// 注册提供者
registerProvider('working', 'mem0', Mem0WorkingMemoryProvider)
```

### 4.3 MinIO 对象存储实现

```typescript
// src/memory/providers/storage/minio.ts

import { Client as MinioClient } from 'minio'
import type { Readable } from 'stream'
import type {
  IObjectStorageProvider,
  HealthStatus,
  UploadOptions,
  MultipartOptions,
  StorageListOptions,
  ObjectMetadata,
  ObjectInfo,
  BucketInfo,
  StorageUsage,
  ListResult,
} from '../../interfaces'
import { registerProvider } from '../factory'

/**
 * MinIO 配置
 */
export interface MinIOConfig {
  endpoint: string
  port?: number
  useSSL?: boolean
  accessKey: string
  secretKey: string
  region?: string
  buckets?: {
    documents?: string
    media?: string
    temp?: string
    exports?: string
  }
}

/**
 * 默认存储桶名称
 */
const DEFAULT_BUCKETS = {
  documents: 'memory-documents',
  media: 'memory-media',
  temp: 'memory-temp',
  exports: 'memory-exports',
}

/**
 * MinIO 对象存储提供者
 */
export class MinIOStorageProvider implements IObjectStorageProvider {
  readonly name = 'minio'
  readonly version = '1.0.0'

  private client: MinioClient | null = null
  private buckets: typeof DEFAULT_BUCKETS

  constructor(private config: MinIOConfig) {
    this.buckets = { ...DEFAULT_BUCKETS, ...config.buckets }
  }

  /**
   * 初始化提供者
   */
  async initialize(): Promise<void> {
    console.log(`[${this.name}] 初始化 MinIO 存储提供者...`)

    this.client = new MinioClient({
      endPoint: this.config.endpoint,
      port: this.config.port ?? 9000,
      useSSL: this.config.useSSL ?? false,
      accessKey: this.config.accessKey,
      secretKey: this.config.secretKey,
      region: this.config.region,
    })

    // 确保必要的存储桶存在
    await this.ensureBuckets()

    console.log(`[${this.name}] 初始化完成`)
  }

  /**
   * 关闭提供者
   */
  async shutdown(): Promise<void> {
    console.log(`[${this.name}] 关闭提供者...`)
    this.client = null
    console.log(`[${this.name}] 已关闭`)
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<HealthStatus> {
    const start = Date.now()

    try {
      if (!this.client) {
        throw new Error('MinIO 客户端未初始化')
      }

      // 尝试列出存储桶
      await this.client.listBuckets()

      return {
        status: 'healthy',
        latency: Date.now() - start,
      }
    } catch (error) {
      return {
        status: 'unhealthy',
        latency: Date.now() - start,
        message: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }

  /**
   * 上传文件
   */
  async upload(
    bucket: string,
    key: string,
    data: Buffer | Readable,
    options?: UploadOptions
  ): Promise<string> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    const metadata: Record<string, string> = {
      'Content-Type': options?.contentType ?? 'application/octet-stream',
      ...options?.metadata,
    }

    if (options?.cacheControl) {
      metadata['Cache-Control'] = options.cacheControl
    }

    if (Buffer.isBuffer(data)) {
      await this.client.putObject(bucket, key, data, data.length, metadata)
    } else {
      await this.client.putObject(bucket, key, data, undefined, metadata)
    }

    console.log(`[${this.name}] 上传文件: ${bucket}/${key}`)
    return `${bucket}/${key}`
  }

  /**
   * 分片上传
   */
  async uploadMultipart(
    bucket: string,
    key: string,
    stream: Readable,
    options?: MultipartOptions
  ): Promise<string> {
    // MinIO 客户端自动处理分片
    return this.upload(bucket, key, stream, options)
  }

  /**
   * 下载文件
   */
  async download(bucket: string, key: string): Promise<Buffer> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    const stream = await this.client.getObject(bucket, key)
    const chunks: Buffer[] = []

    return new Promise((resolve, reject) => {
      stream.on('data', chunk => chunks.push(chunk))
      stream.on('end', () => resolve(Buffer.concat(chunks)))
      stream.on('error', reject)
    })
  }

  /**
   * 获取文件流
   */
  async getStream(bucket: string, key: string): Promise<Readable> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    return this.client.getObject(bucket, key)
  }

  /**
   * 获取预签名下载 URL
   */
  async getSignedUrl(bucket: string, key: string, expiresIn: number = 3600): Promise<string> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    return this.client.presignedGetObject(bucket, key, expiresIn)
  }

  /**
   * 获取预签名上传 URL
   */
  async getSignedUploadUrl(bucket: string, key: string, expiresIn: number = 3600): Promise<string> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    return this.client.presignedPutObject(bucket, key, expiresIn)
  }

  /**
   * 删除文件
   */
  async delete(bucket: string, key: string): Promise<void> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    await this.client.removeObject(bucket, key)
    console.log(`[${this.name}] 删除文件: ${bucket}/${key}`)
  }

  /**
   * 批量删除文件
   */
  async deleteMany(bucket: string, keys: string[]): Promise<void> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    await this.client.removeObjects(bucket, keys)
    console.log(`[${this.name}] 批量删除文件: ${bucket}/ (${keys.length} 个)`)
  }

  /**
   * 复制文件
   */
  async copy(
    srcBucket: string,
    srcKey: string,
    dstBucket: string,
    dstKey: string
  ): Promise<void> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    await this.client.copyObject(dstBucket, dstKey, `/${srcBucket}/${srcKey}`)
    console.log(`[${this.name}] 复制文件: ${srcBucket}/${srcKey} -> ${dstBucket}/${dstKey}`)
  }

  /**
   * 检查文件是否存在
   */
  async exists(bucket: string, key: string): Promise<boolean> {
    try {
      await this.getMetadata(bucket, key)
      return true
    } catch (error) {
      return false
    }
  }

  /**
   * 获取文件元数据
   */
  async getMetadata(bucket: string, key: string): Promise<ObjectMetadata> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    const stat = await this.client.statObject(bucket, key)

    return {
      size: stat.size,
      lastModified: stat.lastModified,
      etag: stat.etag,
      contentType: stat.metaData['content-type'] ?? 'application/octet-stream',
      metadata: stat.metaData,
    }
  }

  /**
   * 列出文件
   */
  async list(
    bucket: string,
    prefix?: string,
    options?: StorageListOptions
  ): Promise<ListResult> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    const objects: ObjectInfo[] = []
    const prefixes: string[] = []

    const stream = this.client.listObjectsV2(bucket, prefix, true, options?.continuationToken)

    return new Promise((resolve, reject) => {
      let count = 0
      const limit = options?.limit ?? 1000

      stream.on('data', obj => {
        if (count >= limit) return

        if (obj.prefix) {
          prefixes.push(obj.prefix)
        } else {
          objects.push({
            key: obj.name,
            size: obj.size,
            lastModified: obj.lastModified,
            etag: obj.etag,
          })
        }
        count++
      })

      stream.on('end', () => {
        resolve({
          objects,
          prefixes,
          isTruncated: false,
        })
      })

      stream.on('error', reject)
    })
  }

  /**
   * 创建存储桶
   */
  async createBucket(bucket: string): Promise<void> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    const exists = await this.client.bucketExists(bucket)
    if (!exists) {
      await this.client.makeBucket(bucket, this.config.region ?? 'us-east-1')
      console.log(`[${this.name}] 创建存储桶: ${bucket}`)
    }
  }

  /**
   * 删除存储桶
   */
  async deleteBucket(bucket: string): Promise<void> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    await this.client.removeBucket(bucket)
    console.log(`[${this.name}] 删除存储桶: ${bucket}`)
  }

  /**
   * 检查存储桶是否存在
   */
  async bucketExists(bucket: string): Promise<boolean> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    return this.client.bucketExists(bucket)
  }

  /**
   * 列出存储桶
   */
  async listBuckets(): Promise<BucketInfo[]> {
    if (!this.client) {
      throw new Error('MinIO 客户端未初始化')
    }

    const buckets = await this.client.listBuckets()
    return buckets.map(b => ({
      name: b.name,
      createdAt: b.creationDate,
    }))
  }

  /**
   * 获取存储用量
   */
  async getStorageUsage(bucket: string, prefix?: string): Promise<StorageUsage> {
    const result = await this.list(bucket, prefix, { limit: 10000 })

    return {
      totalSize: result.objects.reduce((sum, obj) => sum + obj.size, 0),
      objectCount: result.objects.length,
    }
  }

  // ==================== 私有方法 ====================

  /**
   * 确保必要的存储桶存在
   */
  private async ensureBuckets(): Promise<void> {
    for (const bucket of Object.values(this.buckets)) {
      await this.createBucket(bucket)
    }
  }
}

// 注册提供者
registerProvider('storage', 'minio', MinIOStorageProvider)
```

---

## 5. 统一记忆管理器

```typescript
// src/memory/services/manager.ts

import { EventEmitter } from 'events'
import type {
  IWorkingMemoryProvider,
  IEpisodicMemoryProvider,
  IProfileMemoryProvider,
  IKnowledgeMemoryProvider,
  IObjectStorageProvider,
  ProviderConfig,
  HealthStatus,
  Message,
} from '../interfaces'
import {
  createWorkingMemoryProvider,
  createEpisodicMemoryProvider,
  createProfileMemoryProvider,
  createKnowledgeMemoryProvider,
  createObjectStorageProvider,
} from '../providers/factory'

/**
 * 记忆管理器配置
 */
export interface MemoryManagerConfig {
  working: ProviderConfig
  episodic: ProviderConfig
  profile: ProviderConfig
  knowledge: ProviderConfig
  storage: ProviderConfig
}

/**
 * 记忆上下文
 */
export interface MemoryContext {
  userId: string
  sessionId: string

  // 各层记忆快照
  workingMemory: Awaited<ReturnType<IWorkingMemoryProvider['getSession']>>
  recentEpisodes: Awaited<ReturnType<IEpisodicMemoryProvider['getConversationHistory']>>
  facts: Awaited<ReturnType<IProfileMemoryProvider['getFacts']>>
  preferences: Awaited<ReturnType<IProfileMemoryProvider['getPreferences']>>

  // 便捷方法
  addMessage(message: Omit<Message, 'id' | 'createdAt'>): Promise<string>
  searchKnowledge(query: string): Promise<Awaited<ReturnType<IKnowledgeMemoryProvider['searchHybrid']>>>
}

/**
 * 健康报告
 */
export interface HealthReport {
  status: 'healthy' | 'degraded' | 'unhealthy'
  components: {
    working: HealthStatus
    episodic: HealthStatus
    profile: HealthStatus
    knowledge: HealthStatus
    storage: HealthStatus
  }
  timestamp: Date
}

/**
 * 统一记忆管理器
 *
 * 协调各层记忆的访问和同步
 */
export class MemoryManager extends EventEmitter {
  private working: IWorkingMemoryProvider
  private episodic: IEpisodicMemoryProvider
  private profile: IProfileMemoryProvider
  private knowledge: IKnowledgeMemoryProvider
  private storage: IObjectStorageProvider

  private initialized = false

  constructor(config: MemoryManagerConfig) {
    super()

    console.log('[MemoryManager] 创建记忆管理器...')

    this.working = createWorkingMemoryProvider(config.working)
    this.episodic = createEpisodicMemoryProvider(config.episodic)
    this.profile = createProfileMemoryProvider(config.profile)
    this.knowledge = createKnowledgeMemoryProvider(config.knowledge)
    this.storage = createObjectStorageProvider(config.storage)
  }

  /**
   * 初始化所有提供者
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      console.log('[MemoryManager] 已初始化，跳过')
      return
    }

    console.log('[MemoryManager] 初始化所有记忆提供者...')

    await Promise.all([
      this.working.initialize(),
      this.episodic.initialize(),
      this.profile.initialize(),
      this.knowledge.initialize(),
      this.storage.initialize(),
    ])

    this.initialized = true
    this.emit('initialized')
    console.log('[MemoryManager] 初始化完成')
  }

  /**
   * 关闭所有提供者
   */
  async shutdown(): Promise<void> {
    console.log('[MemoryManager] 关闭所有记忆提供者...')

    await Promise.all([
      this.working.shutdown(),
      this.episodic.shutdown(),
      this.profile.shutdown(),
      this.knowledge.shutdown(),
      this.storage.shutdown(),
    ])

    this.initialized = false
    this.emit('shutdown')
    console.log('[MemoryManager] 已关闭')
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<HealthReport> {
    const [working, episodic, profile, knowledge, storage] = await Promise.all([
      this.working.healthCheck(),
      this.episodic.healthCheck(),
      this.profile.healthCheck(),
      this.knowledge.healthCheck(),
      this.storage.healthCheck(),
    ])

    const statuses = [working, episodic, profile, knowledge, storage]
    let overallStatus: HealthReport['status'] = 'healthy'

    if (statuses.some(s => s.status === 'unhealthy')) {
      overallStatus = 'unhealthy'
    } else if (statuses.some(s => s.status === 'degraded')) {
      overallStatus = 'degraded'
    }

    return {
      status: overallStatus,
      components: { working, episodic, profile, knowledge, storage },
      timestamp: new Date(),
    }
  }

  /**
   * 获取记忆上下文
   *
   * 聚合用户的完整记忆状态
   */
  async getContext(userId: string, sessionId: string): Promise<MemoryContext> {
    const [workingMemory, recentEpisodes, facts, preferences] = await Promise.all([
      this.working.getSession(sessionId),
      this.episodic.getConversationHistory(userId, { limit: 5 }),
      this.profile.getFacts(userId),
      this.profile.getPreferences(userId),
    ])

    return {
      userId,
      sessionId,
      workingMemory,
      recentEpisodes,
      facts,
      preferences,

      // 便捷方法
      addMessage: async (message) => {
        return this.working.addMessage(sessionId, message)
      },
      searchKnowledge: async (query) => {
        return this.knowledge.searchHybrid(userId, query)
      },
    }
  }

  /**
   * 会话结束处理
   *
   * 将工作记忆持久化到长期记忆
   */
  async onSessionEnd(userId: string, sessionId: string): Promise<void> {
    console.log(`[MemoryManager] 处理会话结束: ${sessionId}`)

    // 获取会话消息
    const messages = await this.working.getMessages(sessionId)

    if (messages.length === 0) {
      await this.working.deleteSession(sessionId)
      return
    }

    // 并行处理
    const [, , extracted] = await Promise.all([
      // 添加到情节记忆
      this.episodic.addConversation(userId, sessionId, messages),

      // 从对话提取画像
      this.profile.extractFromConversation(userId, messages),

      // 从对话提取知识
      this.knowledge.importConversation(userId, sessionId, messages),
    ])

    // 清理工作记忆
    await this.working.deleteSession(sessionId)

    this.emit('session-processed', {
      userId,
      sessionId,
      messageCount: messages.length,
      extractedEntities: extracted.entities.length,
    })

    console.log(`[MemoryManager] 会话处理完成: ${sessionId}`)
  }

  /**
   * 统一搜索
   *
   * 跨所有记忆层搜索
   */
  async search(userId: string, query: string, options?: {
    limit?: number
    layers?: ('episodic' | 'profile' | 'knowledge')[]
  }): Promise<{
    episodes: Awaited<ReturnType<IEpisodicMemoryProvider['searchEpisodes']>>
    facts: Awaited<ReturnType<IProfileMemoryProvider['searchFacts']>>
    knowledge: Awaited<ReturnType<IKnowledgeMemoryProvider['searchHybrid']>>
  }> {
    const layers = options?.layers ?? ['episodic', 'profile', 'knowledge']
    const limit = options?.limit ?? 10

    const [episodes, facts, knowledge] = await Promise.all([
      layers.includes('episodic')
        ? this.episodic.searchEpisodes(userId, query, { limit })
        : [],
      layers.includes('profile')
        ? this.profile.searchFacts(userId, query)
        : [],
      layers.includes('knowledge')
        ? this.knowledge.searchHybrid(userId, query, { limit })
        : [],
    ])

    return { episodes, facts, knowledge }
  }

  // ==================== 直接访问器 ====================

  get workingMemory(): IWorkingMemoryProvider {
    return this.working
  }

  get episodicMemory(): IEpisodicMemoryProvider {
    return this.episodic
  }

  get profileMemory(): IProfileMemoryProvider {
    return this.profile
  }

  get knowledgeMemory(): IKnowledgeMemoryProvider {
    return this.knowledge
  }

  get objectStorage(): IObjectStorageProvider {
    return this.storage
  }
}
```

---

## 6. API 设计

### 6.1 JSON-RPC 方法

```typescript
// src/memory/api/rpc-methods.ts

import type { MemoryManager } from '../services/manager'
import type {
  SessionOptions,
  Message,
  EpisodicQueryOptions,
  EventQueryOptions,
  DocumentInput,
  VectorSearchOptions,
} from '../interfaces'

/**
 * 记忆系统 RPC 方法
 */
export function createMemoryRpcMethods(manager: MemoryManager) {
  return {
    // ==================== 健康检查 ====================

    'memory.healthCheck': async () => {
      return manager.healthCheck()
    },

    // ==================== 工作记忆 ====================

    'memory.working.createSession': async (params: {
      userId: string
      options?: SessionOptions
    }) => {
      return manager.workingMemory.createSession(params.userId, params.options)
    },

    'memory.working.getSession': async (params: { sessionId: string }) => {
      return manager.workingMemory.getSession(params.sessionId)
    },

    'memory.working.deleteSession': async (params: { sessionId: string }) => {
      return manager.workingMemory.deleteSession(params.sessionId)
    },

    'memory.working.addMessage': async (params: {
      sessionId: string
      message: Omit<Message, 'id' | 'createdAt'>
    }) => {
      return manager.workingMemory.addMessage(params.sessionId, params.message)
    },

    'memory.working.getMessages': async (params: {
      sessionId: string
      limit?: number
    }) => {
      return manager.workingMemory.getMessages(params.sessionId, params.limit)
    },

    'memory.working.getContextWindow': async (params: {
      sessionId: string
      maxTokens: number
    }) => {
      return manager.workingMemory.getContextWindow(params.sessionId, params.maxTokens)
    },

    // ==================== 情节记忆 ====================

    'memory.episodic.getHistory': async (params: {
      userId: string
      options?: EpisodicQueryOptions
    }) => {
      return manager.episodicMemory.getConversationHistory(params.userId, params.options)
    },

    'memory.episodic.getEvents': async (params: {
      userId: string
      options?: EventQueryOptions
    }) => {
      return manager.episodicMemory.getKeyEvents(params.userId, params.options)
    },

    'memory.episodic.search': async (params: {
      userId: string
      query: string
      limit?: number
    }) => {
      return manager.episodicMemory.searchEpisodes(params.userId, params.query, {
        limit: params.limit,
      })
    },

    'memory.episodic.getTimeline': async (params: {
      userId: string
      startDate: string
      endDate: string
    }) => {
      return manager.episodicMemory.getTimeline(
        params.userId,
        new Date(params.startDate),
        new Date(params.endDate)
      )
    },

    // ==================== 画像记忆 ====================

    'memory.profile.getFacts': async (params: {
      userId: string
      category?: string
    }) => {
      return manager.profileMemory.getFacts(params.userId, params.category as any)
    },

    'memory.profile.addFact': async (params: {
      userId: string
      fact: any
    }) => {
      return manager.profileMemory.addFact(params.userId, params.fact)
    },

    'memory.profile.deleteFact': async (params: {
      userId: string
      factId: string
    }) => {
      return manager.profileMemory.deleteFact(params.userId, params.factId)
    },

    'memory.profile.getPreferences': async (params: { userId: string }) => {
      return manager.profileMemory.getPreferences(params.userId)
    },

    'memory.profile.updatePreferences': async (params: {
      userId: string
      updates: any
    }) => {
      return manager.profileMemory.updatePreferences(params.userId, params.updates)
    },

    // ==================== 知识记忆 ====================

    'memory.knowledge.addDocument': async (params: {
      userId: string
      document: DocumentInput
    }) => {
      return manager.knowledgeMemory.addDocument(params.userId, params.document)
    },

    'memory.knowledge.listDocuments': async (params: {
      userId: string
      options?: any
    }) => {
      return manager.knowledgeMemory.listDocuments(params.userId, params.options)
    },

    'memory.knowledge.deleteDocument': async (params: {
      userId: string
      documentId: string
    }) => {
      return manager.knowledgeMemory.deleteDocument(params.userId, params.documentId)
    },

    'memory.knowledge.search': async (params: {
      userId: string
      query: string
      options?: VectorSearchOptions
    }) => {
      return manager.knowledgeMemory.searchHybrid(params.userId, params.query, params.options)
    },

    'memory.knowledge.answer': async (params: {
      userId: string
      question: string
    }) => {
      return manager.knowledgeMemory.answerWithGraph(params.userId, params.question)
    },

    // ==================== 统一操作 ====================

    'memory.getContext': async (params: {
      userId: string
      sessionId: string
    }) => {
      const context = await manager.getContext(params.userId, params.sessionId)
      // 移除函数，只返回数据
      const { addMessage, searchKnowledge, ...data } = context
      return data
    },

    'memory.search': async (params: {
      userId: string
      query: string
      options?: any
    }) => {
      return manager.search(params.userId, params.query, params.options)
    },

    'memory.onSessionEnd': async (params: {
      userId: string
      sessionId: string
    }) => {
      await manager.onSessionEnd(params.userId, params.sessionId)
      return { success: true }
    },
  }
}
```

---

## 7. 配置设计

### 7.1 配置模式

```typescript
// src/memory/config/schema.ts

import { z } from 'zod'

/**
 * 提供者配置模式
 */
const ProviderConfigSchema = z.object({
  provider: z.string(),
  options: z.record(z.unknown()),
})

/**
 * Mem0 配置模式
 */
const Mem0ConfigSchema = z.object({
  apiKey: z.string().optional(),
  baseUrl: z.string().url().optional(),
  sessionTtl: z.number().positive().optional(),
  syncToRemote: z.boolean().optional(),
})

/**
 * Redis 配置模式
 */
const RedisConfigSchema = z.object({
  url: z.string().url(),
  keyPrefix: z.string().optional(),
})

/**
 * PostgreSQL 配置模式
 */
const PostgresConfigSchema = z.object({
  url: z.string(),
  schema: z.string().optional(),
  pool: z.object({
    min: z.number().optional(),
    max: z.number().optional(),
  }).optional(),
})

/**
 * Milvus 配置模式
 */
const MilvusConfigSchema = z.object({
  address: z.string(),
  token: z.string().optional(),
  database: z.string().optional(),
})

/**
 * Neo4j 配置模式
 */
const Neo4jConfigSchema = z.object({
  uri: z.string(),
  username: z.string(),
  password: z.string(),
  database: z.string().optional(),
})

/**
 * MinIO 配置模式
 */
const MinIOConfigSchema = z.object({
  endpoint: z.string(),
  port: z.number().optional(),
  useSSL: z.boolean().optional(),
  accessKey: z.string(),
  secretKey: z.string(),
  region: z.string().optional(),
  buckets: z.object({
    documents: z.string().optional(),
    media: z.string().optional(),
    temp: z.string().optional(),
    exports: z.string().optional(),
  }).optional(),
})

/**
 * 记忆管理器配置模式
 */
export const MemoryConfigSchema = z.object({
  working: ProviderConfigSchema,
  episodic: ProviderConfigSchema,
  profile: ProviderConfigSchema,
  knowledge: ProviderConfigSchema,
  storage: ProviderConfigSchema,
})

export type MemoryConfig = z.infer<typeof MemoryConfigSchema>
```

### 7.2 配置示例

```yaml
# config/memory.yaml

# 工作记忆配置
working:
  provider: mem0
  options:
    apiKey: ${MEM0_API_KEY}
    sessionTtl: 1800000  # 30 分钟
    syncToRemote: true

# 情节记忆配置
episodic:
  provider: mem0
  options:
    apiKey: ${MEM0_API_KEY}

# 画像记忆配置
profile:
  provider: postgres
  options:
    url: ${DATABASE_URL}
    schema: memory

# 知识记忆配置
knowledge:
  provider: graphiti
  options:
    # Milvus 向量存储
    milvus:
      address: ${MILVUS_ADDRESS}
    # Neo4j 图数据库
    neo4j:
      uri: ${NEO4J_URI}
      username: ${NEO4J_USER}
      password: ${NEO4J_PASSWORD}
    # 嵌入模型
    embedding:
      provider: openai
      model: text-embedding-3-small
      dimensions: 1536

# 对象存储配置
storage:
  provider: minio
  options:
    endpoint: ${MINIO_ENDPOINT}
    port: 9000
    useSSL: false
    accessKey: ${MINIO_ACCESS_KEY}
    secretKey: ${MINIO_SECRET_KEY}
    buckets:
      documents: openclaw-documents
      media: openclaw-media
```

---

## 8. 迁移策略

### 8.1 从现有系统迁移

```typescript
// src/memory/services/migration.ts

import { readFile, readdir } from 'fs/promises'
import { join } from 'path'
import type { MemoryManager } from './manager'

/**
 * 迁移服务
 *
 * 从 OpenClaw 现有存储迁移到新记忆系统
 */
export class MigrationService {
  constructor(
    private manager: MemoryManager,
    private config: {
      sessionsDir: string      // ~/.openclaw/sessions/
      agentsDir: string        // ~/.openclaw/agents/
    }
  ) {}

  /**
   * 执行完整迁移
   */
  async migrate(): Promise<MigrationResult> {
    console.log('[Migration] 开始迁移...')

    const result: MigrationResult = {
      sessions: { total: 0, success: 0, failed: 0 },
      transcripts: { total: 0, success: 0, failed: 0 },
      startedAt: new Date(),
      completedAt: null,
      errors: [],
    }

    try {
      // 迁移会话
      await this.migrateSessions(result)

      // 迁移对话记录
      await this.migrateTranscripts(result)

      result.completedAt = new Date()
      console.log('[Migration] 迁移完成:', result)
    } catch (error) {
      result.errors.push(error instanceof Error ? error.message : 'Unknown error')
      console.error('[Migration] 迁移失败:', error)
    }

    return result
  }

  /**
   * 迁移会话 (sessions.json5)
   */
  private async migrateSessions(result: MigrationResult): Promise<void> {
    const sessionsFile = join(this.config.sessionsDir, 'sessions.json5')

    try {
      const content = await readFile(sessionsFile, 'utf-8')
      const sessions = JSON.parse(content)

      for (const [key, session] of Object.entries(sessions)) {
        result.sessions.total++

        try {
          // 解析 SessionKey
          const [agentId, channel, chatType, identifier] = key.split(':')
          const userId = identifier // 简化处理

          // 迁移到情节记忆
          // ... 具体迁移逻辑

          result.sessions.success++
        } catch (error) {
          result.sessions.failed++
          result.errors.push(`Session ${key}: ${error}`)
        }
      }
    } catch (error) {
      console.log('[Migration] 没有找到会话文件或解析失败')
    }
  }

  /**
   * 迁移对话记录 (*.jsonl)
   */
  private async migrateTranscripts(result: MigrationResult): Promise<void> {
    // 遍历 agents 目录下的 sessions 子目录
    // ... 具体迁移逻辑
  }
}

interface MigrationResult {
  sessions: { total: number; success: number; failed: number }
  transcripts: { total: number; success: number; failed: number }
  startedAt: Date
  completedAt: Date | null
  errors: string[]
}
```

---

## 9. 部署架构

### 9.1 嵌入式部署

```yaml
# 直接集成到 OpenClaw Gateway
services:
  gateway:
    image: openclaw/gateway:latest
    environment:
      MEMORY_ENABLED: true
      MEMORY_WORKING_PROVIDER: mem0
      MEMORY_EPISODIC_PROVIDER: mem0
      MEMORY_PROFILE_PROVIDER: postgres
      MEMORY_KNOWLEDGE_PROVIDER: graphiti
      MEMORY_STORAGE_PROVIDER: minio
```

### 9.2 独立服务部署

```yaml
# docker-compose.yaml
version: '3.8'

services:
  memory-service:
    image: openclaw/memory-service:latest
    ports:
      - "8081:8081"
    environment:
      MEM0_API_KEY: ${MEM0_API_KEY}
      DATABASE_URL: postgresql://user:pass@postgres:5432/memory
      MILVUS_ADDRESS: milvus:19530
      NEO4J_URI: bolt://neo4j:7687
      MINIO_ENDPOINT: minio
    depends_on:
      - postgres
      - milvus
      - neo4j
      - minio

  postgres:
    image: postgres:16
    volumes:
      - postgres_data:/var/lib/postgresql/data

  milvus:
    image: milvusdb/milvus:latest
    volumes:
      - milvus_data:/var/lib/milvus

  neo4j:
    image: neo4j:5
    volumes:
      - neo4j_data:/data

  minio:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data

volumes:
  postgres_data:
  milvus_data:
  neo4j_data:
  minio_data:
```

---

## 10. 实施计划

| 阶段 | 任务 | 产出 |
|------|------|------|
| **Phase 1** | 接口定义 + 工厂模式 | 完整接口定义，提供者注册机制 |
| **Phase 2** | 工作记忆实现 | Mem0 + 内存提供者 |
| **Phase 3** | 情节记忆实现 | Mem0 提供者 |
| **Phase 4** | 画像记忆实现 | PostgreSQL 提供者 |
| **Phase 5** | MinIO 对象存储 | MinIO 提供者 + 媒体处理 |
| **Phase 6** | 知识记忆实现 | Graphiti + Milvus 提供者 |
| **Phase 7** | 统一管理器 + API | MemoryManager + RPC 方法 |
| **Phase 8** | 迁移工具 + 测试 | 迁移服务 + 完整测试 |

---

*— 文档结束 —*
